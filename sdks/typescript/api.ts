/* tslint:disable */
/* eslint-disable */
/**
 * SnapTrade
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * https://konfigthis.com
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIDisclaimerAcceptRequest
 */
export interface APIDisclaimerAcceptRequest {
    /**
     * A boolean that indicates whether this user has accepted the disclaimer or not.
     * @type {boolean}
     * @memberof APIDisclaimerAcceptRequest
     */
    'accepted'?: boolean;
}
/**
 * SnapTradeUser Investment Account
 * @export
 * @interface Account
 */
export interface Account {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'brokerage_authorization'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'portfolio_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'institution_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created_date'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'meta'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<CashRestriction>}
     * @memberof Account
     */
    'cash_restrictions'?: Array<CashRestriction>;
}
/**
 * Account Holdings
 * @export
 * @interface AccountHoldings
 */
export interface AccountHoldings {
    [key: string]: any;

    /**
     * 
     * @type {SnapTradeHoldingsAccount}
     * @memberof AccountHoldings
     */
    'account'?: SnapTradeHoldingsAccount;
    /**
     * 
     * @type {Array<Balance>}
     * @memberof AccountHoldings
     */
    'balances'?: Array<Balance>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof AccountHoldings
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {SnapTradeHoldingsTotalValue}
     * @memberof AccountHoldings
     */
    'total_value'?: SnapTradeHoldingsTotalValue;
}
/**
 * Record of order in brokerageaccount
 * @export
 * @interface AccountOrderRecord
 */
export interface AccountOrderRecord {
    [key: string]: any;

    /**
     * Order id returned by brokerage
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'brokerage_order_id'?: string;
    /**
     * 
     * @type {AccountOrderRecordStatus}
     * @memberof AccountOrderRecord
     */
    'status'?: AccountOrderRecordStatus;
    /**
     * 
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'symbol'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof AccountOrderRecord
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {Action}
     * @memberof AccountOrderRecord
     */
    'action'?: Action;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'total_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'open_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'canceled_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'filled_quantity'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'execution_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'limit_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'stop_price'?: number;
    /**
     * 
     * @type {OrderType}
     * @memberof AccountOrderRecord
     */
    'order_type'?: OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof AccountOrderRecord
     */
    'time_in_force'?: TimeInForce;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'time_placed'?: string;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'time_updated'?: string;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'expiry_date'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountOrderRecordStatus = {
    None: 'NONE',
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Failed: 'FAILED',
    Rejected: 'REJECTED',
    Canceled: 'CANCELED',
    PartialCanceled: 'PARTIAL_CANCELED',
    CancelPending: 'CANCEL_PENDING',
    Executed: 'EXECUTED',
    Partial: 'PARTIAL',
    ReplacePending: 'REPLACE_PENDING',
    Replaced: 'REPLACED',
    Stopped: 'STOPPED',
    Suspended: 'SUSPENDED',
    Expired: 'EXPIRED',
    Queued: 'QUEUED',
    Triggered: 'TRIGGERED',
    Activated: 'ACTIVATED',
    PendingRiskReview: 'PENDING_RISK_REVIEW',
    ContingentOrder: 'CONTINGENT_ORDER'
} as const;

export type AccountOrderRecordStatus = typeof AccountOrderRecordStatus[keyof typeof AccountOrderRecordStatus];


/**
 * SnapTradeUser Investment Account
 * @export
 * @interface AccountSimple
 */
export interface AccountSimple {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'number'?: string;
}
/**
 * Trade Action
 * @export
 * @enum {string}
 */

export const Action = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type Action = typeof Action[keyof typeof Action];


/**
 * @type AuthenticationLoginSnapTradeUser200Response
 * @export
 */
export type AuthenticationLoginSnapTradeUser200Response = EncryptedResponse | LoginRedirectURI;

/**
 * Account Balance
 * @export
 * @interface Balance
 */
export interface Balance {
    [key: string]: any;

    /**
     * 
     * @type {Currency}
     * @memberof Balance
     */
    'currency'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'cash'?: number;
}
/**
 * 
 * @export
 * @interface Brokerage
 */
export interface Brokerage {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'aws_s3_logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'maintenance_mode'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_fractional_units'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_trading'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'has_reporting'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'is_real_time_connection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_trading_through_snaptrade_api'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'is_scraping_integration'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'default_currency'?: string;
    /**
     * 
     * @type {BrokerageType}
     * @memberof Brokerage
     */
    'brokerage_type'?: BrokerageType;
    /**
     * List of exchange ID supported by brokerage
     * @type {Array<any>}
     * @memberof Brokerage
     */
    'exchanges'?: Array<any>;
}
/**
 * 
 * @export
 * @interface BrokerageAuthorization
 */
export interface BrokerageAuthorization {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'id'?: string;
    /**
     * Time
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'created_date'?: string;
    /**
     * Time
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'updated_date'?: string;
    /**
     * 
     * @type {Brokerage}
     * @memberof BrokerageAuthorization
     */
    'brokerage'?: Brokerage;
    /**
     * Connection Name
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BrokerageAuthorization
     */
    'disabled'?: boolean;
    /**
     * Disabled date
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'disabled_date'?: string | null;
    /**
     * Additional data about brokerage authorization
     * @type {{ [key: string]: any; }}
     * @memberof BrokerageAuthorization
     */
    'meta'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BrokerageAuthorizationType
 */
export interface BrokerageAuthorizationType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationType
     */
    'type'?: BrokerageAuthorizationTypeTypeEnum;
}

export const BrokerageAuthorizationTypeTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type BrokerageAuthorizationTypeTypeEnum = typeof BrokerageAuthorizationTypeTypeEnum[keyof typeof BrokerageAuthorizationTypeTypeEnum];

/**
 * 
 * @export
 * @interface BrokerageAuthorizationTypeReadOnly
 */
export interface BrokerageAuthorizationTypeReadOnly {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'type'?: BrokerageAuthorizationTypeReadOnlyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'auth_type'?: BrokerageAuthorizationTypeReadOnlyAuthTypeEnum;
    /**
     * 
     * @type {BrokerageAuthorizationTypeReadOnlyBrokerage}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'brokerage'?: BrokerageAuthorizationTypeReadOnlyBrokerage;
}

export const BrokerageAuthorizationTypeReadOnlyTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type BrokerageAuthorizationTypeReadOnlyTypeEnum = typeof BrokerageAuthorizationTypeReadOnlyTypeEnum[keyof typeof BrokerageAuthorizationTypeReadOnlyTypeEnum];
export const BrokerageAuthorizationTypeReadOnlyAuthTypeEnum = {
    Oauth: 'OAUTH',
    Scrape: 'SCRAPE',
    UnofficialApi: 'UNOFFICIAL_API',
    Token: 'TOKEN'
} as const;

export type BrokerageAuthorizationTypeReadOnlyAuthTypeEnum = typeof BrokerageAuthorizationTypeReadOnlyAuthTypeEnum[keyof typeof BrokerageAuthorizationTypeReadOnlyAuthTypeEnum];

/**
 * 
 * @export
 * @interface BrokerageAuthorizationTypeReadOnlyBrokerage
 */
export interface BrokerageAuthorizationTypeReadOnlyBrokerage {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'id'?: string;
    /**
     * Name of Brokerage
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'name'?: string;
    /**
     * Slug of Brokerage. It is usually the name of the brokerage in capital letters
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'slug'?: string;
}
/**
 * Brokerage symbol
 * @export
 * @interface BrokerageSymbol
 */
export interface BrokerageSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof BrokerageSymbol
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {BrokerageAuthorization}
     * @memberof BrokerageSymbol
     */
    'brokerage_authorization'?: BrokerageAuthorization;
    /**
     * 
     * @type {string}
     * @memberof BrokerageSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BrokerageSymbol
     */
    'allows_fractional_units'?: boolean;
}
/**
 * Type of brokerage
 * @export
 * @interface BrokerageType
 */
export interface BrokerageType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageType
     */
    'name'?: string;
}
/**
 * Array of trades to make to rebalance portfolio
 * @export
 * @interface CalculatedTrade
 */
export interface CalculatedTrade {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CalculatedTrade
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Trade>}
     * @memberof CalculatedTrade
     */
    'trades'?: Array<Trade>;
}
/**
 * Cash restriction rules that apply to this account when undergoing portfolio rebalance calculations.
 * @export
 * @interface CashRestriction
 */
export interface CashRestriction {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'type'?: CashRestrictionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CashRestriction
     */
    'amount'?: number;
}

export const CashRestrictionTypeEnum = {
    AllocateMax: 'ALLOCATE_MAX',
    RetainMin: 'RETAIN_MIN'
} as const;

export type CashRestrictionTypeEnum = typeof CashRestrictionTypeEnum[keyof typeof CashRestrictionTypeEnum];

/**
 * Currency
 * @export
 * @interface Currency
 */
export interface Currency {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
}
/**
 * Response when delete user is successful
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    [key: string]: any;

    /**
     * Delete status
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'status'?: string;
    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface DividendAtDate
 */
export interface DividendAtDate {
    [key: string]: any;

    /**
     * The ticker of the symbol that the dividend came from
     * @type {string}
     * @memberof DividendAtDate
     */
    'symbol'?: string;
    /**
     * The amount received from the dividend
     * @type {number}
     * @memberof DividendAtDate
     */
    'amount'?: number;
    /**
     * The currency of the amount
     * @type {string}
     * @memberof DividendAtDate
     */
    'currency'?: string;
}
/**
 * This response consists of 2 different components that must be decrypted to obtain the decrypted message  * Decrypting the encryptedSharedKey    The encrypted shared key is a shared key that was randomly generated by SnapTrade and encrypted using the users SSH public key provided when registering the user   It is needed to decrypt the message in step 2.    To decrypt the shared key, the user should have access to their SSH private key stored locally in their device    An example Python code on how to decrypt the shared key is shown below    ```   def decrypt_rsa_message(self, encrypted_message):       from Crypto.Cipher import PKCS1_OAEP       from Crypto.PublicKey import RSA       from base64 import b64decode        f = open(\'private.pem\', \'r\')       private_key = RSA.import_key(f.read())       cipher = PKCS1_OAEP.new(private_key)        return cipher.decrypt(b64decode(encrypted_message.encode())).decode()   ```  * Decrypting the encryptedMessageData     The data meant to be returned by an endpoint can be obtained by decrypting the encrypted message     An encrypted message is a message that is encrypted using AES - MODE OCB with the shared key obtained in step one    An example code to decrypt the encrypted message is shown below    ```   def decrypt_aes_message(self, shared_key, encrypted_message):       from Crypto.Cipher import AES       from base64 import b64decode        encrypted_msg = b64decode(encrypted_message[\"encryptedMessage\"].encode())       tag = b64decode(encrypted_message[\"tag\"].encode())       nonce = b64decode(encrypted_message[\"nonce\"].encode())       cipher = AES.new(shared_key.encode(), AES.MODE_OCB, nonce=nonce)        return cipher.decrypt_and_verify(encrypted_msg, tag).decode()   ``` 
 * @export
 * @interface EncryptedResponse
 */
export interface EncryptedResponse {
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponse
     */
    'encryptedSharedKey'?: string;
    /**
     * 
     * @type {EncryptedResponseEncryptedMessageData}
     * @memberof EncryptedResponse
     */
    'encryptedMessageData'?: EncryptedResponseEncryptedMessageData;
}
/**
 * 
 * @export
 * @interface EncryptedResponseEncryptedMessageData
 */
export interface EncryptedResponseEncryptedMessageData {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'encryptedMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'nonce'?: string;
}
/**
 * Stock Exchange
 * @export
 * @interface Exchange
 */
export interface Exchange {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'close_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'suffix'?: string;
}
/**
 * The exchange rate of a pair of currencies
 * @export
 * @interface ExchangeRatePairs
 */
export interface ExchangeRatePairs {
    [key: string]: any;

    /**
     * 
     * @type {Currency}
     * @memberof ExchangeRatePairs
     */
    'src'?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof ExchangeRatePairs
     */
    'dst'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRatePairs
     */
    'exchange_rate'?: number;
}
/**
 * An excluded asset in a portfolio group
 * @export
 * @interface ExcludedAsset
 */
export interface ExcludedAsset {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ExcludedAsset
     */
    'symbol'?: UniversalSymbol;
}
/**
 * JWT Token. Used to acess resources in private endpoints available only through the Passiv app
 * @export
 * @interface JWT
 */
export interface JWT {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof JWT
     */
    'token'?: string;
}
/**
 * Redirect uri upon successful login
 * @export
 * @interface LoginRedirectURI
 */
export interface LoginRedirectURI {
    /**
     * 
     * @type {any}
     * @memberof LoginRedirectURI
     */
    'redirectURI'?: any;
    /**
     * 
     * @type {string}
     * @memberof LoginRedirectURI
     */
    'sessionId'?: string;
}
/**
 * A manual trade object
 * @export
 * @interface ManualTrade
 */
export interface ManualTrade {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ManualTrade
     */
    'id'?: string;
    /**
     * 
     * @type {Account}
     * @memberof ManualTrade
     */
    'account'?: Account;
    /**
     * 
     * @type {OrderType}
     * @memberof ManualTrade
     */
    'order_type'?: OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof ManualTrade
     */
    'time_in_force'?: TimeInForce;
    /**
     * 
     * @type {ManualTradeSymbol}
     * @memberof ManualTrade
     */
    'symbol'?: ManualTradeSymbol;
    /**
     * 
     * @type {Action}
     * @memberof ManualTrade
     */
    'action'?: Action;
    /**
     * Trade Units
     * @type {number}
     * @memberof ManualTrade
     */
    'units'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof ManualTrade
     */
    'price'?: number;
}
/**
 * Manual Trade and Impact object
 * @export
 * @interface ManualTradeAndImpact
 */
export interface ManualTradeAndImpact {
    [key: string]: any;

    /**
     * 
     * @type {ManualTrade}
     * @memberof ManualTradeAndImpact
     */
    'trade'?: ManualTrade;
    /**
     * 
     * @type {Array<ManualTrade>}
     * @memberof ManualTradeAndImpact
     */
    'trade_impacts'?: Array<ManualTrade>;
    /**
     * 
     * @type {ManualTradeBalance}
     * @memberof ManualTradeAndImpact
     */
    'combined_remaining_balance'?: ManualTradeBalance;
}
/**
 * Balance
 * @export
 * @interface ManualTradeBalance
 */
export interface ManualTradeBalance {
    [key: string]: any;

    /**
     * 
     * @type {Account}
     * @memberof ManualTradeBalance
     */
    'account'?: Account;
    /**
     * 
     * @type {Currency}
     * @memberof ManualTradeBalance
     */
    'currency'?: Currency;
    /**
     * Cash
     * @type {number}
     * @memberof ManualTradeBalance
     */
    'cash'?: number;
}
/**
 * Manual Trade Form
 * @export
 * @interface ManualTradeForm
 */
export interface ManualTradeForm {
    /**
     * 
     * @type {string}
     * @memberof ManualTradeForm
     */
    'account_id'?: string;
    /**
     * 
     * @type {Action}
     * @memberof ManualTradeForm
     */
    'action'?: Action;
    /**
     * 
     * @type {OrderType}
     * @memberof ManualTradeForm
     */
    'order_type'?: OrderType;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof ManualTradeForm
     */
    'price'?: number;
    /**
     * Stop Price. If stop loss or stop limit order, the price to trigger the stop
     * @type {number}
     * @memberof ManualTradeForm
     */
    'stop'?: number;
    /**
     * 
     * @type {TimeInForce}
     * @memberof ManualTradeForm
     */
    'time_in_force'?: TimeInForce;
    /**
     * Trade Units
     * @type {number}
     * @memberof ManualTradeForm
     */
    'units'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeForm
     */
    'universal_symbol_id'?: string;
}
/**
 * Manual trade symbol object
 * @export
 * @interface ManualTradeSymbol
 */
export interface ManualTradeSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'brokerage_symbol_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'universal_symbol_id'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof ManualTradeSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'symbol'?: string;
}
/**
 * Example for failed request response
 * @export
 * @interface Model400FailedRequestResponse
 */
export interface Model400FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model400FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model400FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model401FailedRequestResponse
 */
export interface Model401FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model401FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model401FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model403FailedRequestResponse
 */
export interface Model403FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model403FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model403FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model404FailedRequestResponse
 */
export interface Model404FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model404FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model404FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * 
 * @export
 * @interface ModelAssetClass
 */
export interface ModelAssetClass {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ModelAssetClass
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAssetClass
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelAssetClassDetails
 */
export interface ModelAssetClassDetails {
    /**
     * 
     * @type {ModelAssetClass}
     * @memberof ModelAssetClassDetails
     */
    'model_asset_class'?: ModelAssetClass;
    /**
     * 
     * @type {Array<ModelAssetClassTarget>}
     * @memberof ModelAssetClassDetails
     */
    'model_asset_class_target'?: Array<ModelAssetClassTarget>;
}
/**
 * 
 * @export
 * @interface ModelAssetClassTarget
 */
export interface ModelAssetClassTarget {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ModelAssetClassTarget
     */
    'symbol'?: UniversalSymbol;
}
/**
 * 
 * @export
 * @interface ModelPortfolio
 */
export interface ModelPortfolio {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ModelPortfolio
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPortfolio
     */
    'name'?: string;
    /**
     * Enum definitions -> [-1: Unassigned, 0: Security Model Portfolio, 1: Asset Class Portfolio]
     * @type {number}
     * @memberof ModelPortfolio
     */
    'model_type'?: ModelPortfolioModelTypeEnum;
}

export const ModelPortfolioModelTypeEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ModelPortfolioModelTypeEnum = typeof ModelPortfolioModelTypeEnum[keyof typeof ModelPortfolioModelTypeEnum];

/**
 * 
 * @export
 * @interface ModelPortfolioAssetClass
 */
export interface ModelPortfolioAssetClass {
    [key: string]: any;

    /**
     * 
     * @type {ModelAssetClass}
     * @memberof ModelPortfolioAssetClass
     */
    'model_asset_class'?: ModelAssetClass;
    /**
     * 
     * @type {number}
     * @memberof ModelPortfolioAssetClass
     */
    'percent'?: number;
}
/**
 * 
 * @export
 * @interface ModelPortfolioDetails
 */
export interface ModelPortfolioDetails {
    /**
     * 
     * @type {ModelPortfolio}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio'?: ModelPortfolio;
    /**
     * 
     * @type {Array<ModelPortfolioSecurity>}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio_security'?: Array<ModelPortfolioSecurity>;
    /**
     * 
     * @type {Array<ModelPortfolioAssetClass>}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio_asset_class'?: Array<ModelPortfolioAssetClass>;
}
/**
 * 
 * @export
 * @interface ModelPortfolioSecurity
 */
export interface ModelPortfolioSecurity {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ModelPortfolioSecurity
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof ModelPortfolioSecurity
     */
    'percent'?: number;
}
/**
 * 
 * @export
 * @interface MonthlyDividends
 */
export interface MonthlyDividends {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof MonthlyDividends
     */
    'date'?: string;
    /**
     * 
     * @type {Array<DividendAtDate>}
     * @memberof MonthlyDividends
     */
    'dividends'?: Array<DividendAtDate>;
}
/**
 * 
 * @export
 * @interface NetContributions
 */
export interface NetContributions {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof NetContributions
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetContributions
     */
    'contributions'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetContributions
     */
    'currency'?: string;
}
/**
 * Object representing total dividends received during a timeframe
 * @export
 * @interface NetDividend
 */
export interface NetDividend {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof NetDividend
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof NetDividend
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetDividend
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface OptionChainInner
 */
export interface OptionChainInner {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'listingExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'optionExerciseType'?: string;
    /**
     * 
     * @type {Array<OptionChainInnerChainPerRootInner>}
     * @memberof OptionChainInner
     */
    'chainPerRoot'?: Array<OptionChainInnerChainPerRootInner>;
}
/**
 * 
 * @export
 * @interface OptionChainInnerChainPerRootInner
 */
export interface OptionChainInnerChainPerRootInner {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'optionRoot'?: string;
    /**
     * 
     * @type {Array<OptionChainInnerChainPerRootInnerChainPerStrikePriceInner>}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'chainPerStrikePrice'?: Array<OptionChainInnerChainPerRootInnerChainPerStrikePriceInner>;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'multiplier'?: number;
}
/**
 * 
 * @export
 * @interface OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
 */
export interface OptionChainInnerChainPerRootInnerChainPerStrikePriceInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'strikePrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'callSymbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'putSymbolId'?: number;
}
/**
 * Option Leg
 * @export
 * @interface OptionLeg
 */
export interface OptionLeg {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionLeg
     */
    'action'?: OptionLegActionEnum;
    /**
     * Obtained from calling options chain endpoint (option_id)
     * @type {string}
     * @memberof OptionLeg
     */
    'option_symbol_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionLeg
     */
    'quantity'?: number;
}

export const OptionLegActionEnum = {
    BuyToOpen: 'BUY_TO_OPEN',
    BuyToClose: 'BUY_TO_CLOSE',
    SellToOpen: 'SELL_TO_OPEN',
    SellToClose: 'SELL_TO_CLOSE'
} as const;

export type OptionLegActionEnum = typeof OptionLegActionEnum[keyof typeof OptionLegActionEnum];

/**
 * 
 * @export
 * @interface OptionStrategy
 */
export interface OptionStrategy {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionStrategy
     */
    'id'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof OptionStrategy
     */
    'underlying_symbol_id'?: UniversalSymbol;
    /**
     * 
     * @type {string}
     * @memberof OptionStrategy
     */
    'strategy_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionStrategy
     */
    'number_of_legs'?: number;
    /**
     * 
     * @type {Array<OptionStrategyLegsInner>}
     * @memberof OptionStrategy
     */
    'legs'?: Array<OptionStrategyLegsInner>;
}
/**
 * 
 * @export
 * @interface OptionStrategyLegsInner
 */
export interface OptionStrategyLegsInner {
    /**
     * 
     * @type {string}
     * @memberof OptionStrategyLegsInner
     */
    'option_symbol_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionStrategyLegsInner
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof OptionStrategyLegsInner
     */
    'action'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionStrategyLegsInner
     */
    'quantity'?: number;
}
/**
 * 
 * @export
 * @interface OptionsGetOptionStrategyRequest
 */
export interface OptionsGetOptionStrategyRequest {
    /**
     * 
     * @type {string}
     * @memberof OptionsGetOptionStrategyRequest
     */
    'underlying_symbol_id': string;
    /**
     * 
     * @type {Array<OptionLeg>}
     * @memberof OptionsGetOptionStrategyRequest
     */
    'legs': Array<OptionLeg>;
    /**
     * 
     * @type {string}
     * @memberof OptionsGetOptionStrategyRequest
     */
    'strategy_type': OptionsGetOptionStrategyRequestStrategyTypeEnum;
}

export const OptionsGetOptionStrategyRequestStrategyTypeEnum = {
    Custom: 'CUSTOM'
} as const;

export type OptionsGetOptionStrategyRequestStrategyTypeEnum = typeof OptionsGetOptionStrategyRequestStrategyTypeEnum[keyof typeof OptionsGetOptionStrategyRequestStrategyTypeEnum];

/**
 * Option Holdings
 * @export
 * @interface OptionsHoldings
 */
export interface OptionsHoldings {
    [key: string]: any;

    /**
     * Options information
     * @type {string}
     * @memberof OptionsHoldings
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionsHoldings
     */
    'symbol'?: string;
    /**
     * 
     * @type {OptionsSymbol}
     * @memberof OptionsHoldings
     */
    'option_symbol'?: OptionsSymbol;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof OptionsHoldings
     */
    'price'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof OptionsHoldings
     */
    'currency'?: Currency;
    /**
     * Average purchase price for this position
     * @type {number}
     * @memberof OptionsHoldings
     */
    'average_purchase_price'?: number;
}
/**
 * 
 * @export
 * @interface OptionsPlaceOptionStrategyRequest
 */
export interface OptionsPlaceOptionStrategyRequest {
    /**
     * 
     * @type {string}
     * @memberof OptionsPlaceOptionStrategyRequest
     */
    'order_type': OptionsPlaceOptionStrategyRequestOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OptionsPlaceOptionStrategyRequest
     */
    'time_in_force': OptionsPlaceOptionStrategyRequestTimeInForceEnum;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof OptionsPlaceOptionStrategyRequest
     */
    'price': number;
}

export const OptionsPlaceOptionStrategyRequestOrderTypeEnum = {
    Limit: 'Limit',
    Market: 'Market',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit'
} as const;

export type OptionsPlaceOptionStrategyRequestOrderTypeEnum = typeof OptionsPlaceOptionStrategyRequestOrderTypeEnum[keyof typeof OptionsPlaceOptionStrategyRequestOrderTypeEnum];
export const OptionsPlaceOptionStrategyRequestTimeInForceEnum = {
    Day: 'DAY',
    Gtc: 'GTC'
} as const;

export type OptionsPlaceOptionStrategyRequestTimeInForceEnum = typeof OptionsPlaceOptionStrategyRequestTimeInForceEnum[keyof typeof OptionsPlaceOptionStrategyRequestTimeInForceEnum];

/**
 * Option Holdings
 * @export
 * @interface OptionsPosition
 */
export interface OptionsPosition {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionsPosition
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionsPosition
     */
    'description'?: string;
    /**
     * 
     * @type {OptionsSymbol}
     * @memberof OptionsPosition
     */
    'option_symbol'?: OptionsSymbol;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof OptionsPosition
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptionsPosition
     */
    'units'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof OptionsPosition
     */
    'currency'?: Currency;
    /**
     * Average purchase price for this position
     * @type {number}
     * @memberof OptionsPosition
     */
    'average_purchase_price'?: number;
}
/**
 * Options Symbol
 * @export
 * @interface OptionsSymbol
 */
export interface OptionsSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'ticker'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionsSymbol
     */
    'strike_price'?: number;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_mini_option'?: boolean;
    /**
     * 
     * @type {UnderlyingSymbol}
     * @memberof OptionsSymbol
     */
    'underlying_symbol'?: UnderlyingSymbol;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {any}
     * @memberof OptionsSymbol
     */
    'security_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof OptionsSymbol
     */
    'listing_exchange'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_quotable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_tradable'?: boolean;
}
/**
 * Order Type
 * @export
 * @enum {string}
 */

export const OrderType = {
    Limit: 'Limit',
    Market: 'Market',
    StopLimit: 'StopLimit',
    StopLoss: 'StopLoss'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * SnapTrade Partner metadata
 * @export
 * @interface PartnerData
 */
export interface PartnerData {
    [key: string]: any;

    /**
     * URI to redirect user back to after user is done adding brokerage connections
     * @type {string}
     * @memberof PartnerData
     */
    'redirect_uri'?: string;
    /**
     * Brokerages that can be accessed by partners
     * @type {Array<Brokerage>}
     * @memberof PartnerData
     */
    'allowed_brokerages'?: Array<Brokerage>;
    /**
     * Name of Snaptrade Partner
     * @type {string}
     * @memberof PartnerData
     */
    'name'?: string;
    /**
     * Slug of Snaptrade Partner
     * @type {string}
     * @memberof PartnerData
     */
    'slug'?: string;
    /**
     * URL to partner\'s logo
     * @type {string}
     * @memberof PartnerData
     */
    'logo_url'?: string;
    /**
     * Shows if pin is required by users to access connection page
     * @type {boolean}
     * @memberof PartnerData
     */
    'pin_required'?: boolean;
    /**
     * Shows if users of Snaptrade partners can access trade endpoints
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_trades'?: boolean;
    /**
     * Shows if Snaptrade partners can get user holdings data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_holdings'?: boolean;
    /**
     * Shows if Snaptrade partners can get users account history data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_account_history'?: boolean;
    /**
     * Shows if Snaptrade partners can get users holdings data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_reference_data'?: boolean;
    /**
     * Shows if users Snaptrade partners can access portfolio group management features
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_portfolio_management'?: boolean;
    /**
     * Shows if Snaptrade partners can get users account order history
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_orders'?: boolean;
}
/**
 * 
 * @export
 * @interface PastValue
 */
export interface PastValue {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof PastValue
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof PastValue
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof PastValue
     */
    'currency'?: string;
}
/**
 * Performance Custom Response Object
 * @export
 * @interface PerformanceCustom
 */
export interface PerformanceCustom {
    [key: string]: any;

    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'totalEquityTimeframe'?: Array<PastValue>;
    /**
     * 
     * @type {NetContributions}
     * @memberof PerformanceCustom
     */
    'contributions'?: NetContributions;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'contributionTimeframe'?: Array<PastValue>;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'contributionTimeframeCumulative'?: Array<PastValue>;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'withdrawalTimeframe'?: Array<PastValue>;
    /**
     * Current streak of cosecutive months where contributions were made
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionStreak'?: number;
    /**
     * Number of months in the timeframe with contributions
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionMonthsContributed'?: number;
    /**
     * Total months in timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionTotalMonths'?: number;
    /**
     * 
     * @type {Array<NetDividend>}
     * @memberof PerformanceCustom
     */
    'dividends'?: Array<NetDividend>;
    /**
     * Total dividends received over the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'dividendIncome'?: number;
    /**
     * Average dividends received per month over the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'monthlyDividends'?: number;
    /**
     * list of tickers which may not be supported or may not have accurate price data
     * @type {Array<string>}
     * @memberof PerformanceCustom
     */
    'badTickers'?: Array<string>;
    /**
     * 
     * @type {Array<MonthlyDividends>}
     * @memberof PerformanceCustom
     */
    'dividendTimeline'?: Array<MonthlyDividends>;
    /**
     * commissions incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'commissions'?: number;
    /**
     * forex fees incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'forexFees'?: number;
    /**
     * other fees incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'fees'?: number;
    /**
     * The return rate over the timeframe. Annualized if timeframe is longer than 1 year
     * @type {number}
     * @memberof PerformanceCustom
     */
    'rateOfReturn'?: number;
    /**
     * 
     * @type {Array<SubPeriodReturnRate>}
     * @memberof PerformanceCustom
     */
    'returnRateTimeframe'?: Array<SubPeriodReturnRate>;
    /**
     * Whether the user has detailed mode enabled (more frequent data points for totalEquity and contribution timeframes)
     * @type {boolean}
     * @memberof PerformanceCustom
     */
    'detailedMode'?: boolean;
}
/**
 * 
 * @export
 * @interface PortfolioGroup
 */
export interface PortfolioGroup {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof PortfolioGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioGroup
     */
    'name'?: string;
}
/**
 * Summary of all relevant information about a portfolio group.
 * @export
 * @interface PortfolioGroupInfo
 */
export interface PortfolioGroupInfo {
    [key: string]: any;

    /**
     * 
     * @type {Array<UniversalSymbol>}
     * @memberof PortfolioGroupInfo
     */
    'symbols'?: Array<UniversalSymbol>;
    /**
     * 
     * @type {Array<UniversalSymbol>}
     * @memberof PortfolioGroupInfo
     */
    'quotable_symbols'?: Array<UniversalSymbol>;
    /**
     * 
     * @type {Array<Balance>}
     * @memberof PortfolioGroupInfo
     */
    'balances'?: Array<Balance>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof PortfolioGroupInfo
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {Array<TargetAsset>}
     * @memberof PortfolioGroupInfo
     */
    'target_positions'?: Array<TargetAsset>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof PortfolioGroupInfo
     */
    'ideal_positions'?: Array<Position>;
    /**
     * 
     * @type {Array<ExcludedAsset>}
     * @memberof PortfolioGroupInfo
     */
    'excluded_positions'?: Array<ExcludedAsset>;
    /**
     * 
     * @type {Array<CalculatedTrade>}
     * @memberof PortfolioGroupInfo
     */
    'calculated_trades'?: Array<CalculatedTrade>;
    /**
     * 
     * @type {Array<BrokerageAuthorization>}
     * @memberof PortfolioGroupInfo
     */
    'brokerage_authorizations'?: Array<BrokerageAuthorization>;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupInfo
     */
    'accuracy'?: number;
    /**
     * 
     * @type {PortfolioGroupSettings}
     * @memberof PortfolioGroupInfo
     */
    'settings'?: PortfolioGroupSettings;
}
/**
 * Details of a security held
 * @export
 * @interface PortfolioGroupPosition
 */
export interface PortfolioGroupPosition {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof PortfolioGroupPosition
     */
    'symbol'?: UniversalSymbol;
    /**
     * Last known market price for the symbol
     * @type {number}
     * @memberof PortfolioGroupPosition
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupPosition
     */
    'units'?: number;
}
/**
 * 
 * @export
 * @interface PortfolioGroupSettings
 */
export interface PortfolioGroupSettings {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof PortfolioGroupSettings
     */
    'buyOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioGroupSettings
     */
    'cash_optimizer'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioGroupSettings
     */
    'notifyFrequency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupSettings
     */
    'driftThreshold'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof PortfolioGroupSettings
     */
    'preferred_currency'?: Currency;
}
/**
 * Account Position
 * @export
 * @interface Position
 */
export interface Position {
    [key: string]: any;

    /**
     * 
     * @type {PositionSymbol}
     * @memberof Position
     */
    'symbol'?: PositionSymbol;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'units'?: number;
    /**
     * Last known market price for the symbol
     * @type {number}
     * @memberof Position
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'open_pnl'?: number;
    /**
     * Deprecated, use the units field for both fractional and integer units going forward
     * @type {number}
     * @memberof Position
     */
    'fractional_units'?: number | null;
    /**
     * Average purchase price for this position. Either returned by the underlying broker or calculated using historical transactions.
     * @type {number}
     * @memberof Position
     */
    'average_purchase_price'?: number;
}
/**
 * Symbol returned in position object
 * @export
 * @interface PositionSymbol
 */
export interface PositionSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof PositionSymbol
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSymbol
     */
    'is_quotable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSymbol
     */
    'is_tradable'?: boolean;
}
/**
 * Response when register user is successful
 * @export
 * @interface RedirectTokenandPin
 */
export interface RedirectTokenandPin {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof RedirectTokenandPin
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectTokenandPin
     */
    'pin'?: string;
}
/**
 * Security Type
 * @export
 * @interface SecurityType
 */
export interface SecurityType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SecurityType
     */
    'is_supported'?: boolean;
}
/**
 * Status of user acceptance of SnapTrade API disclaimer
 * @export
 * @interface SnapTradeAPIDisclaimerAcceptStatus
 */
export interface SnapTradeAPIDisclaimerAcceptStatus {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof SnapTradeAPIDisclaimerAcceptStatus
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeAPIDisclaimerAcceptStatus
     */
    'timestamp'?: string;
}
/**
 * SnapTradeUser Investment Account
 * @export
 * @interface SnapTradeHoldingsAccount
 */
export interface SnapTradeHoldingsAccount {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'id'?: string;
    /**
     * 
     * @type {BrokerageAuthorization}
     * @memberof SnapTradeHoldingsAccount
     */
    'brokerage_authorization'?: BrokerageAuthorization;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'portfolio_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'institution_name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SnapTradeHoldingsAccount
     */
    'meta'?: { [key: string]: any; };
}
/**
 * Total Value of the account
 * @export
 * @interface SnapTradeHoldingsTotalValue
 */
export interface SnapTradeHoldingsTotalValue {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof SnapTradeHoldingsTotalValue
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsTotalValue
     */
    'currency'?: string;
}
/**
 * Data to login a user via SnapTrade Partner
 * @export
 * @interface SnapTradeLoginUserRequestBody
 */
export interface SnapTradeLoginUserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'broker'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'immediateRedirect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'customRedirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'reconnect'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'connectionType'?: SnapTradeLoginUserRequestBodyConnectionTypeEnum;
}

export const SnapTradeLoginUserRequestBodyConnectionTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type SnapTradeLoginUserRequestBodyConnectionTypeEnum = typeof SnapTradeLoginUserRequestBodyConnectionTypeEnum[keyof typeof SnapTradeLoginUserRequestBodyConnectionTypeEnum];

/**
 * Data required to register a user via SnapTrade Partner
 * @export
 * @interface SnapTradeRegisterUserRequestBody
 */
export interface SnapTradeRegisterUserRequestBody {
    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof SnapTradeRegisterUserRequestBody
     */
    'userId'?: string;
    /**
     * Open SSH RSA public key
     * @type {string}
     * @memberof SnapTradeRegisterUserRequestBody
     */
    'rsaPublicKey'?: string;
}
/**
 * Status of API
 * @export
 * @interface Status
 */
export interface Status {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'online'?: boolean;
}
/**
 * The strategy impact
 * @export
 * @interface StrategyImpact
 */
export interface StrategyImpact {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'estimatedCommissions'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'buyingPowerEffect'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'buyingPowerResult'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'maintExcessEffect'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'maintExcessResult'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'tradeValueCalculation'?: string;
    /**
     * 
     * @type {Array<StrategyImpactLegsInner>}
     * @memberof StrategyImpact
     */
    'legs'?: Array<StrategyImpactLegsInner>;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'effect'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'strategy'?: string;
}
/**
 * 
 * @export
 * @interface StrategyImpactLegsInner
 */
export interface StrategyImpactLegsInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'legId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'legRatioQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'avgExecPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'lastExecPrice'?: string;
}
/**
 * The reponse for a correctly placed order
 * @export
 * @interface StrategyOrderPlace
 */
export interface StrategyOrderPlace {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlace
     */
    'orderId'?: number;
    /**
     * 
     * @type {Array<StrategyOrderPlaceOrdersInner>}
     * @memberof StrategyOrderPlace
     */
    'orders'?: Array<StrategyOrderPlaceOrdersInner>;
}
/**
 * 
 * @export
 * @interface StrategyOrderPlaceOrdersInner
 */
export interface StrategyOrderPlaceOrdersInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'totalQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'openQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'filledQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'canceledQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderType'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'limitPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'stopPrice'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isAllOrNone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isAnonymous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'icebergQuantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'minQuantity'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'avgExecPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'lastExecPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'timeInForce'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'gtdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'rejectionReason'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'chainId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'primaryRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'secondaryRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'venueHoldingOrder'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'comissionCharged'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'exchangeOrderId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isSignificantShareHolder'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isInsider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isLimitOffsetInDollar'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'placementCommission'?: string;
    /**
     * 
     * @type {Array<StrategyOrderPlaceOrdersInnerLegsInner>}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'legs'?: Array<StrategyOrderPlaceOrdersInnerLegsInner>;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'strategyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'triggerStopPrice'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderGroupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderClass'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isCrossZero'?: boolean;
}
/**
 * 
 * @export
 * @interface StrategyOrderPlaceOrdersInnerLegsInner
 */
export interface StrategyOrderPlaceOrdersInnerLegsInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'legId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'legRatioQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'side'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'avgExecPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'lastExecPrice'?: string;
}
/**
 * Strategy order record
 * @export
 * @interface StrategyOrderRecord
 */
export interface StrategyOrderRecord {
    [key: string]: any;

    /**
     * 
     * @type {OptionStrategy}
     * @memberof StrategyOrderRecord
     */
    'strategy'?: OptionStrategy;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderRecord
     */
    'status'?: StrategyOrderRecordStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderRecord
     */
    'filled_quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderRecord
     */
    'open_quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderRecord
     */
    'closed_quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderRecord
     */
    'order_type'?: StrategyOrderRecordOrderTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderRecord
     */
    'time_in_force'?: StrategyOrderRecordTimeInForceEnum;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof StrategyOrderRecord
     */
    'limit_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof StrategyOrderRecord
     */
    'execution_price'?: number;
    /**
     * Time
     * @type {string}
     * @memberof StrategyOrderRecord
     */
    'time_placed'?: string;
    /**
     * Time
     * @type {string}
     * @memberof StrategyOrderRecord
     */
    'time_updated'?: string;
}

export const StrategyOrderRecordStatusEnum = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Failed: 'FAILED',
    Rejected: 'REJECTED',
    Canceled: 'CANCELED',
    PartialCanceled: 'PARTIAL_CANCELED',
    CancelPending: 'CANCEL_PENDING',
    Executed: 'EXECUTED',
    Partial: 'PARTIAL',
    ReplacePending: 'REPLACE_PENDING',
    Replaced: 'REPLACED',
    Stopped: 'STOPPED',
    Suspended: 'SUSPENDED',
    Expired: 'EXPIRED',
    Queued: 'QUEUED',
    Triggered: 'TRIGGERED',
    Activated: 'ACTIVATED',
    PendingRiskReview: 'PENDING_RISK_REVIEW',
    ContingentOrder: 'CONTINGENT_ORDER'
} as const;

export type StrategyOrderRecordStatusEnum = typeof StrategyOrderRecordStatusEnum[keyof typeof StrategyOrderRecordStatusEnum];
export const StrategyOrderRecordOrderTypeEnum = {
    Limit: 'Limit',
    Market: 'Market',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit'
} as const;

export type StrategyOrderRecordOrderTypeEnum = typeof StrategyOrderRecordOrderTypeEnum[keyof typeof StrategyOrderRecordOrderTypeEnum];
export const StrategyOrderRecordTimeInForceEnum = {
    Day: 'DAY',
    Gtc: 'GTC'
} as const;

export type StrategyOrderRecordTimeInForceEnum = typeof StrategyOrderRecordTimeInForceEnum[keyof typeof StrategyOrderRecordTimeInForceEnum];

/**
 * 
 * @export
 * @interface StrategyQuotes
 */
export interface StrategyQuotes {
    [key: string]: any;

    /**
     * 
     * @type {OptionStrategy}
     * @memberof StrategyQuotes
     */
    'strategy'?: OptionStrategy;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof StrategyQuotes
     */
    'open_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof StrategyQuotes
     */
    'bid_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof StrategyQuotes
     */
    'ask_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotes
     */
    'volatility'?: number;
    /**
     * 
     * @type {StrategyQuotesGreek}
     * @memberof StrategyQuotes
     */
    'greek'?: StrategyQuotesGreek;
}
/**
 * 
 * @export
 * @interface StrategyQuotesGreek
 */
export interface StrategyQuotesGreek {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesGreek
     */
    'delta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesGreek
     */
    'gamma'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesGreek
     */
    'theta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesGreek
     */
    'vega'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesGreek
     */
    'rho'?: number;
}
/**
 * 
 * @export
 * @interface SubPeriodReturnRate
 */
export interface SubPeriodReturnRate {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof SubPeriodReturnRate
     */
    'periodStart'?: string;
    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof SubPeriodReturnRate
     */
    'periodEnd'?: string;
    /**
     * The return rate for the given period
     * @type {number}
     * @memberof SubPeriodReturnRate
     */
    'rateOfReturn'?: number;
}
/**
 * Symbol
 * @export
 * @interface Symbol
 */
export interface Symbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'raw_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'name'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Symbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Exchange}
     * @memberof Symbol
     */
    'exchange'?: Exchange;
}
/**
 * Symbol query for searching for symbols
 * @export
 * @interface SymbolQuery
 */
export interface SymbolQuery {
    /**
     * 
     * @type {string}
     * @memberof SymbolQuery
     */
    'substring'?: string;
}
/**
 * Symbols and Tickers Quotes object
 * @export
 * @interface SymbolsQuotes
 */
export interface SymbolsQuotes {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof SymbolsQuotes
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'bid_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'ask_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'last_trade_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'bid_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'ask_size'?: number;
}
/**
 * Target percentage of a certain asset
 * @export
 * @interface TargetAsset
 */
export interface TargetAsset {
    /**
     * 
     * @type {string}
     * @memberof TargetAsset
     */
    'id'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof TargetAsset
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof TargetAsset
     */
    'percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TargetAsset
     */
    'is_supported'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TargetAsset
     */
    'is_excluded'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof TargetAsset
     */
    'meta'?: object;
}
/**
 * Trade time in force:   * FOK - Fill Or Kill   * Day - Day   * GTC - Good Til Canceled 
 * @export
 * @enum {string}
 */

export const TimeInForce = {
    Day: 'Day',
    Fok: 'FOK',
    Gtc: 'GTC'
} as const;

export type TimeInForce = typeof TimeInForce[keyof typeof TimeInForce];


/**
 * A trade object
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    'id'?: string;
    /**
     * 
     * @type {Account}
     * @memberof Trade
     */
    'account'?: Account;
    /**
     * 
     * @type {BrokerageSymbol}
     * @memberof Trade
     */
    'symbol'?: BrokerageSymbol;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof Trade
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    'action'?: TradeActionEnum;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'units'?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'sequence'?: number;
}

export const TradeActionEnum = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type TradeActionEnum = typeof TradeActionEnum[keyof typeof TradeActionEnum];

/**
 * Execution status of a trade
 * @export
 * @interface TradeExecutionStatus
 */
export interface TradeExecutionStatus {
    [key: string]: any;

    /**
     * 
     * @type {BrokerageSymbol}
     * @memberof TradeExecutionStatus
     */
    'symbol'?: BrokerageSymbol;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof TradeExecutionStatus
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {Trade}
     * @memberof TradeExecutionStatus
     */
    'trade'?: Trade;
    /**
     * Execution state of a trade
     * @type {string}
     * @memberof TradeExecutionStatus
     */
    'state'?: TradeExecutionStatusStateEnum;
    /**
     * Number of filled units
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'filled_units'?: number;
    /**
     * Action of executed trade
     * @type {string}
     * @memberof TradeExecutionStatus
     */
    'action'?: TradeExecutionStatusActionEnum;
    /**
     * Price of execution
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'price'?: number;
    /**
     * Fees paid from executing trade
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'commissions'?: number;
    /**
     * Other misc. data
     * @type {{ [key: string]: any; }}
     * @memberof TradeExecutionStatus
     */
    'meta'?: { [key: string]: any; };
}

export const TradeExecutionStatusStateEnum = {
    Executed: 'Executed',
    Canceled: 'Canceled',
    Rejected: 'Rejected',
    Failed: 'Failed',
    NotExecuted: 'Not Executed'
} as const;

export type TradeExecutionStatusStateEnum = typeof TradeExecutionStatusStateEnum[keyof typeof TradeExecutionStatusStateEnum];
export const TradeExecutionStatusActionEnum = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type TradeExecutionStatusActionEnum = typeof TradeExecutionStatusActionEnum[keyof typeof TradeExecutionStatusActionEnum];

/**
 * Impact of a group of trade
 * @export
 * @interface TradeImpact
 */
export interface TradeImpact {
    [key: string]: any;

    /**
     * 
     * @type {Account}
     * @memberof TradeImpact
     */
    'account'?: Account;
    /**
     * 
     * @type {Currency}
     * @memberof TradeImpact
     */
    'currency'?: Currency;
    /**
     * Remaining balance after executing all trades
     * @type {number}
     * @memberof TradeImpact
     */
    'remaining_cash'?: number;
    /**
     * Total estimated commissions across all trades to make
     * @type {number}
     * @memberof TradeImpact
     */
    'estimated_commissions'?: number;
    /**
     * Estimated forex fees to pay to excute trades
     * @type {number}
     * @memberof TradeImpact
     */
    'forex_fees'?: number;
}
/**
 * 
 * @export
 * @interface TradingPlaceOCOOrderRequest
 */
export interface TradingPlaceOCOOrderRequest {
    /**
     * The ID of first trade object obtained from trade/impact endpoint
     * @type {any}
     * @memberof TradingPlaceOCOOrderRequest
     */
    'first_trade_id'?: any;
    /**
     * The ID of second trade object obtained from trade/impact endpoint
     * @type {any}
     * @memberof TradingPlaceOCOOrderRequest
     */
    'second_trade_id'?: any;
}
/**
 * US Stock Exchange
 * @export
 * @interface USExchange
 */
export interface USExchange {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'close_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'suffix'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof USExchange
     */
    'allows_cryptocurrency_symbols'?: boolean;
}
/**
 * Underlying Symbol
 * @export
 * @interface UnderlyingSymbol
 */
export interface UnderlyingSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof UnderlyingSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {USExchange}
     * @memberof UnderlyingSymbol
     */
    'exchange'?: USExchange;
    /**
     * 
     * @type {SecurityType}
     * @memberof UnderlyingSymbol
     */
    'type'?: SecurityType;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof UnderlyingSymbol
     */
    'currencies'?: Array<Currency>;
}
/**
 * A transaction or activity from an institution
 * @export
 * @interface UniversalActivity
 */
export interface UniversalActivity {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'id'?: string;
    /**
     * 
     * @type {AccountSimple}
     * @memberof UniversalActivity
     */
    'account'?: AccountSimple;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'amount'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof UniversalActivity
     */
    'currency'?: Currency;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'fee'?: number;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'institution'?: string;
    /**
     * If an option transaction, then it\'s type (BUY_TO_OPEN, SELL_TO_CLOSE, etc), otherwise empty string
     * @type {string}
     * @memberof UniversalActivity
     */
    'option_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'settlement_date'?: string;
    /**
     * 
     * @type {Symbol}
     * @memberof UniversalActivity
     */
    'symbol'?: Symbol;
    /**
     * 
     * @type {OptionsSymbol}
     * @memberof UniversalActivity
     */
    'option_symbol'?: OptionsSymbol;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'trade_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'type'?: UniversalActivityTypeEnum;
    /**
     * Usually but not necessarily an integer
     * @type {number}
     * @memberof UniversalActivity
     */
    'units'?: number;
}

export const UniversalActivityTypeEnum = {
    Dividend: 'DIVIDEND',
    Buy: 'BUY',
    Sell: 'SELL',
    Contribution: 'CONTRIBUTION',
    Withdrawal: 'WITHDRAWAL',
    ExternalAssetTransferIn: 'EXTERNAL_ASSET_TRANSFER_IN',
    ExternalAssetTransferOut: 'EXTERNAL_ASSET_TRANSFER_OUT',
    InternalCashTransferIn: 'INTERNAL_CASH_TRANSFER_IN',
    InternalCashTransferOut: 'INTERNAL_CASH_TRANSFER_OUT',
    InternalAssetTransferIn: 'INTERNAL_ASSET_TRANSFER_IN',
    InternalAssetTransferOut: 'INTERNAL_ASSET_TRANSFER_OUT',
    Interest: 'INTEREST',
    Rebate: 'REBATE',
    GovGrant: 'GOV_GRANT',
    Tax: 'TAX',
    Fee: 'FEE',
    Rei: 'REI',
    Fxt: 'FXT'
} as const;

export type UniversalActivityTypeEnum = typeof UniversalActivityTypeEnum[keyof typeof UniversalActivityTypeEnum];

/**
 * Universal symbol
 * @export
 * @interface UniversalSymbol
 */
export interface UniversalSymbol {
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'raw_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof UniversalSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Exchange}
     * @memberof UniversalSymbol
     */
    'exchange'?: Exchange;
    /**
     * 
     * @type {SecurityType}
     * @memberof UniversalSymbol
     */
    'type'?: SecurityType;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof UniversalSymbol
     */
    'currencies'?: Array<Currency>;
}
/**
 * Universal symbol
 * @export
 * @interface UniversalSymbolTicker
 */
export interface UniversalSymbolTicker {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UniversalSymbolTicker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbolTicker
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbolTicker
     */
    'raw_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbolTicker
     */
    'description'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof UniversalSymbolTicker
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Exchange}
     * @memberof UniversalSymbolTicker
     */
    'exchange'?: Exchange;
    /**
     * 
     * @type {SecurityType}
     * @memberof UniversalSymbolTicker
     */
    'type'?: SecurityType;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof UniversalSymbolTicker
     */
    'currencies'?: Array<Currency>;
}
/**
 * An API error log for a specific SnapTrade user.
 * @export
 * @interface UserErrorLog
 */
export interface UserErrorLog {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'requestedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'response'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserErrorLog
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'queryParams'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'httpMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'endpoint'?: string;
}
/**
 * Response when register user is successful
 * @export
 * @interface UserIDandSecret
 */
export interface UserIDandSecret {
    [key: string]: any;

    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof UserIDandSecret
     */
    'userId'?: string;
    /**
     * SnapTrade User Secret randomly generated by Passiv.
     * @type {string}
     * @memberof UserIDandSecret
     */
    'userSecret'?: string;
}
/**
 * Passiv user account settings
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'receive_cash_notification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'receive_drift_notification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'user_trial_activated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'activated_trial_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'demo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'api_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserSettings
     */
    'drift_threshold'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof UserSettings
     */
    'preferred_currency'?: Currency;
}

/**
 * APIDisclaimerApi - axios parameter creator
 * @export
 */
export const APIDisclaimerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {APIDisclaimerAcceptRequest} aPIDisclaimerAcceptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accept: async (userId: string, userSecret: string, aPIDisclaimerAcceptRequest: APIDisclaimerAcceptRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accept', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accept', 'userSecret', userSecret)
            // verify required parameter 'aPIDisclaimerAcceptRequest' is not null or undefined
            assertParamExists('accept', 'aPIDisclaimerAcceptRequest', aPIDisclaimerAcceptRequest)
            const localVarPath = `/snapTrade/acceptDisclaimer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIDisclaimerAcceptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIDisclaimerApi - functional programming interface
 * @export
 */
export const APIDisclaimerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIDisclaimerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {APIDisclaimerAcceptRequest} aPIDisclaimerAcceptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accept(userId: string, userSecret: string, aPIDisclaimerAcceptRequest: APIDisclaimerAcceptRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapTradeAPIDisclaimerAcceptStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accept(userId, userSecret, aPIDisclaimerAcceptRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIDisclaimerApi - factory interface
 * @export
 */
export const APIDisclaimerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIDisclaimerApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {APIDisclaimerAcceptRequest} aPIDisclaimerAcceptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accept(userId: string, userSecret: string, aPIDisclaimerAcceptRequest: APIDisclaimerAcceptRequest, options?: any): AxiosPromise<SnapTradeAPIDisclaimerAcceptStatus> {
            return localVarFp.accept(userId, userSecret, aPIDisclaimerAcceptRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIDisclaimerApi - object-oriented interface
 * @export
 * @class APIDisclaimerApi
 * @extends {BaseAPI}
 */
export class APIDisclaimerApi extends BaseAPI {
    /**
     * 
     * @summary Accept or Reject SnapTrade disclaimer agreement
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {APIDisclaimerAcceptRequest} aPIDisclaimerAcceptRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIDisclaimerApi
     */
    public accept(userId: string, userSecret: string, aPIDisclaimerAcceptRequest: APIDisclaimerAcceptRequest, options?: AxiosRequestConfig) {
        return APIDisclaimerApiFp(this.configuration).accept(userId, userSecret, aPIDisclaimerAcceptRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * APIStatusApi - axios parameter creator
 * @export
 */
export const APIStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIStatusApi - functional programming interface
 * @export
 */
export const APIStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async check(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.check(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIStatusApi - factory interface
 * @export
 */
export const APIStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIStatusApiFp(configuration)
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check(options?: any): AxiosPromise<Status> {
            return localVarFp.check(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIStatusApi - object-oriented interface
 * @export
 * @class APIStatusApi
 * @extends {BaseAPI}
 */
export class APIStatusApi extends BaseAPI {
    /**
     * Check whether the API is operational and verify timestamps.
     * @summary Get API Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIStatusApi
     */
    public check(options?: AxiosRequestConfig) {
        return APIStatusApiFp(this.configuration).check(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountInformationApi - axios parameter creator
 * @export
 */
export const AccountInformationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserHoldings: async (userId: string, userSecret: string, brokerageAuthorizations?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAllUserHoldings', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getAllUserHoldings', 'userSecret', userSecret)
            const localVarPath = `/holdings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (brokerageAuthorizations !== undefined) {
                localVarQueryParameter['brokerage_authorizations'] = brokerageAuthorizations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalance: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountBalance', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountBalance', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountBalance', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountDetails: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountDetails', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountDetails', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountDetails', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountOrders: async (userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountOrders', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountOrders', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountOrders', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountPositions: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountPositions', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountPositions', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountPositions', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/positions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHoldings: async (accountId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserHoldings', 'accountId', accountId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserHoldings', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserHoldings', 'userSecret', userSecret)
            const localVarPath = `/accounts/{accountId}/holdings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserAccounts', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('listUserAccounts', 'userSecret', userSecret)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAccount: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserAccount', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('updateUserAccount', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('updateUserAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInformationApi - functional programming interface
 * @export
 */
export const AccountInformationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInformationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUserHoldings(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountHoldings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUserHoldings(userId, userSecret, brokerageAuthorizations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountBalance(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountBalance(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountDetails(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountDetails(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountOrders(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountOrderRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountOrders(userId, userSecret, accountId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountPositions(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountPositions(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHoldings(accountId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHoldings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserHoldings(accountId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserAccounts(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserAccounts(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAccount(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAccount(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountInformationApi - factory interface
 * @export
 */
export const AccountInformationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInformationApiFp(configuration)
    return {
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUserHoldings(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: any): AxiosPromise<Array<AccountHoldings>> {
            return localVarFp.getAllUserHoldings(userId, userSecret, brokerageAuthorizations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalance(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.getUserAccountBalance(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountDetails(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.getUserAccountDetails(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountOrders(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: any): AxiosPromise<Array<AccountOrderRecord>> {
            return localVarFp.getUserAccountOrders(userId, userSecret, accountId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountPositions(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.getUserAccountPositions(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHoldings(accountId: string, userId: string, userSecret: string, options?: any): AxiosPromise<AccountHoldings> {
            return localVarFp.getUserHoldings(accountId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserAccounts(userId: string, userSecret: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.listUserAccounts(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAccount(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.updateUserAccount(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInformationApi - object-oriented interface
 * @export
 * @class AccountInformationApi
 * @extends {BaseAPI}
 */
export class AccountInformationApi extends BaseAPI {
    /**
     * 
     * @summary List all accounts for the user, plus balances and positions for each account.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getAllUserHoldings(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getAllUserHoldings(userId, userSecret, brokerageAuthorizations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all cash balances of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getUserAccountBalance(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getUserAccountBalance(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return details of a specific investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account to get detail of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getUserAccountDetails(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getUserAccountDetails(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all history of orders placed in account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getUserAccountOrders(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getUserAccountOrders(userId, userSecret, accountId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all positions of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getUserAccountPositions(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getUserAccountPositions(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List balances, positions and orders for the specified account.
     * @param {string} accountId The ID of the account to fetch holdings for.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public getUserHoldings(accountId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).getUserHoldings(accountId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all investment accounts for the user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public listUserAccounts(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).listUserAccounts(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update details of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public updateUserAccount(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).updateUserAccount(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapTradeUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteSnapTradeUser', 'userId', userId)
            const localVarPath = `/snapTrade/deleteUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJWT: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserJWT', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserJWT', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/encryptedJWT`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapTradeUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapTrade/listUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginSnapTradeUser: async (userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('loginSnapTradeUser', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('loginSnapTradeUser', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapTradeLoginUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSnapTradeUser: async (snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapTradeRegisterUserRequestBody' is not null or undefined
            assertParamExists('registerSnapTradeUser', 'snapTradeRegisterUserRequestBody', snapTradeRegisterUserRequestBody)
            const localVarPath = `/snapTrade/registerUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapTradeRegisterUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSnapTradeUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSnapTradeUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserJWT(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserJWT(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSnapTradeUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSnapTradeUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginSnapTradeUser(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationLoginSnapTradeUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginSnapTradeUser(userId, userSecret, snapTradeLoginUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerSnapTradeUser(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIDandSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerSnapTradeUser(snapTradeRegisterUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSnapTradeUser(userId: string, options?: any): AxiosPromise<DeleteUserResponse> {
            return localVarFp.deleteSnapTradeUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserJWT(userId: string, userSecret: string, options?: any): AxiosPromise<EncryptedResponse> {
            return localVarFp.getUserJWT(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSnapTradeUsers(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listSnapTradeUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginSnapTradeUser(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: any): AxiosPromise<AuthenticationLoginSnapTradeUser200Response> {
            return localVarFp.loginSnapTradeUser(userId, userSecret, snapTradeLoginUserRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerSnapTradeUser(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: any): AxiosPromise<UserIDandSecret> {
            return localVarFp.registerSnapTradeUser(snapTradeRegisterUserRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deleteSnapTradeUser(userId: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deleteSnapTradeUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getUserJWT(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getUserJWT(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all SnapTrade users you\'ve registered on our platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public listSnapTradeUsers(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).listSnapTradeUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginSnapTradeUser(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginSnapTradeUser(userId, userSecret, snapTradeLoginUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register user with SnapTrade in order to create secure brokerage authorizations
     * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public registerSnapTradeUser(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).registerSnapTradeUser(snapTradeRegisterUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailBrokerageAuthorization: async (authorizationId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('detailBrokerageAuthorization', 'authorizationId', authorizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('detailBrokerageAuthorization', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('detailBrokerageAuthorization', 'userSecret', userSecret)
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBrokerageAuthorizations: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listBrokerageAuthorizations', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('listBrokerageAuthorizations', 'userSecret', userSecret)
            const localVarPath = `/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBrokerageAuthorization: async (authorizationId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('removeBrokerageAuthorization', 'authorizationId', authorizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeBrokerageAuthorization', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('removeBrokerageAuthorization', 'userSecret', userSecret)
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrokerageAuthorization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailBrokerageAuthorization(authorizationId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBrokerageAuthorizations(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrokerageAuthorization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBrokerageAuthorizations(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBrokerageAuthorization(authorizationId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: any): AxiosPromise<BrokerageAuthorization> {
            return localVarFp.detailBrokerageAuthorization(authorizationId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBrokerageAuthorizations(userId: string, userSecret: string, options?: any): AxiosPromise<Array<BrokerageAuthorization>> {
            return localVarFp.listBrokerageAuthorizations(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeBrokerageAuthorization(authorizationId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Get detail of a specific brokerage authorizations for the user
     * @param {string} authorizationId The ID of a brokerage authorization object.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public detailBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).detailBrokerageAuthorization(authorizationId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all brokerage authorizations for the user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public listBrokerageAuthorizations(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).listBrokerageAuthorizations(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a brokerage authorization.
     * @param {string} authorizationId The ID of the Authorization to delete.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public removeBrokerageAuthorization(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).removeBrokerageAuthorization(authorizationId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ErrorLogsApi - axios parameter creator
 * @export
 */
export const ErrorLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserErrors: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserErrors', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('listUserErrors', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/listUserErrors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorLogsApi - functional programming interface
 * @export
 */
export const ErrorLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserErrors(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserErrorLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserErrors(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorLogsApi - factory interface
 * @export
 */
export const ErrorLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserErrors(userId: string, userSecret: string, options?: any): AxiosPromise<Array<UserErrorLog>> {
            return localVarFp.listUserErrors(userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorLogsApi - object-oriented interface
 * @export
 * @class ErrorLogsApi
 * @extends {BaseAPI}
 */
export class ErrorLogsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve error logs on behalf of your SnapTrade users
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorLogsApi
     */
    public listUserErrors(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ErrorLogsApiFp(this.configuration).listUserErrors(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an option strategy object that will be used to place an option strategy order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {OptionsGetOptionStrategyRequest} optionsGetOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionStrategy: async (userId: string, userSecret: string, accountId: string, optionsGetOptionStrategyRequest: OptionsGetOptionStrategyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOptionStrategy', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getOptionStrategy', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOptionStrategy', 'accountId', accountId)
            // verify required parameter 'optionsGetOptionStrategyRequest' is not null or undefined
            assertParamExists('getOptionStrategy', 'optionsGetOptionStrategyRequest', optionsGetOptionStrategyRequest)
            const localVarPath = `/accounts/{accountId}/optionStrategy`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(optionsGetOptionStrategyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol Universal symbol ID if symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain: async (userId: string, userSecret: string, accountId: string, symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOptionsChain', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getOptionsChain', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOptionsChain', 'accountId', accountId)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOptionsChain', 'symbol', symbol)
            const localVarPath = `/accounts/{accountId}/optionsChain`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get latest market data of option strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsStrategyQuote: async (userId: string, userSecret: string, accountId: string, optionStrategyId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOptionsStrategyQuote', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getOptionsStrategyQuote', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getOptionsStrategyQuote', 'accountId', accountId)
            // verify required parameter 'optionStrategyId' is not null or undefined
            assertParamExists('getOptionsStrategyQuote', 'optionStrategyId', optionStrategyId)
            const localVarPath = `/accounts/{accountId}/optionStrategy/{optionStrategyId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"optionStrategyId"}}`, encodeURIComponent(String(optionStrategyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionHoldings: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listOptionHoldings', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('listOptionHoldings', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('listOptionHoldings', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/options`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an option strategy order on the brokerage
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {OptionsPlaceOptionStrategyRequest} optionsPlaceOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOptionStrategy: async (userId: string, userSecret: string, accountId: string, optionStrategyId: string, optionsPlaceOptionStrategyRequest: OptionsPlaceOptionStrategyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeOptionStrategy', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeOptionStrategy', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('placeOptionStrategy', 'accountId', accountId)
            // verify required parameter 'optionStrategyId' is not null or undefined
            assertParamExists('placeOptionStrategy', 'optionStrategyId', optionStrategyId)
            // verify required parameter 'optionsPlaceOptionStrategyRequest' is not null or undefined
            assertParamExists('placeOptionStrategy', 'optionsPlaceOptionStrategyRequest', optionsPlaceOptionStrategyRequest)
            const localVarPath = `/accounts/{accountId}/optionStrategy/{optionStrategyId}/execute`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"optionStrategyId"}}`, encodeURIComponent(String(optionStrategyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(optionsPlaceOptionStrategyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an option strategy object that will be used to place an option strategy order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {OptionsGetOptionStrategyRequest} optionsGetOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionStrategy(userId: string, userSecret: string, accountId: string, optionsGetOptionStrategyRequest: OptionsGetOptionStrategyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyQuotes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionStrategy(userId, userSecret, accountId, optionsGetOptionStrategyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol Universal symbol ID if symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsChain(userId: string, userSecret: string, accountId: string, symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionChainInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsChain(userId, userSecret, accountId, symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get latest market data of option strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOptionsStrategyQuote(userId: string, userSecret: string, accountId: string, optionStrategyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyQuotes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOptionsStrategyQuote(userId, userSecret, accountId, optionStrategyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOptionHoldings(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsHoldings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOptionHoldings(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an option strategy order on the brokerage
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {OptionsPlaceOptionStrategyRequest} optionsPlaceOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOptionStrategy(userId: string, userSecret: string, accountId: string, optionStrategyId: string, optionsPlaceOptionStrategyRequest: OptionsPlaceOptionStrategyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOptionStrategy(userId, userSecret, accountId, optionStrategyId, optionsPlaceOptionStrategyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OptionsApi - factory interface
 * @export
 */
export const OptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an option strategy object that will be used to place an option strategy order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {OptionsGetOptionStrategyRequest} optionsGetOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionStrategy(userId: string, userSecret: string, accountId: string, optionsGetOptionStrategyRequest: OptionsGetOptionStrategyRequest, options?: any): AxiosPromise<StrategyQuotes> {
            return localVarFp.getOptionStrategy(userId, userSecret, accountId, optionsGetOptionStrategyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol Universal symbol ID if symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsChain(userId: string, userSecret: string, accountId: string, symbol: string, options?: any): AxiosPromise<Array<OptionChainInner>> {
            return localVarFp.getOptionsChain(userId, userSecret, accountId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get latest market data of option strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOptionsStrategyQuote(userId: string, userSecret: string, accountId: string, optionStrategyId: string, options?: any): AxiosPromise<StrategyQuotes> {
            return localVarFp.getOptionsStrategyQuote(userId, userSecret, accountId, optionStrategyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOptionHoldings(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<OptionsHoldings> {
            return localVarFp.listOptionHoldings(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an option strategy order on the brokerage
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
         * @param {OptionsPlaceOptionStrategyRequest} optionsPlaceOptionStrategyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOptionStrategy(userId: string, userSecret: string, accountId: string, optionStrategyId: string, optionsPlaceOptionStrategyRequest: OptionsPlaceOptionStrategyRequest, options?: any): AxiosPromise<StrategyOrderRecord> {
            return localVarFp.placeOptionStrategy(userId, userSecret, accountId, optionStrategyId, optionsPlaceOptionStrategyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OptionsApi - object-oriented interface
 * @export
 * @class OptionsApi
 * @extends {BaseAPI}
 */
export class OptionsApi extends BaseAPI {
    /**
     * 
     * @summary Creates an option strategy object that will be used to place an option strategy order
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {OptionsGetOptionStrategyRequest} optionsGetOptionStrategyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOptionStrategy(userId: string, userSecret: string, accountId: string, optionsGetOptionStrategyRequest: OptionsGetOptionStrategyRequest, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOptionStrategy(userId, userSecret, accountId, optionsGetOptionStrategyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the options chain
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} symbol Universal symbol ID if symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOptionsChain(userId: string, userSecret: string, accountId: string, symbol: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOptionsChain(userId, userSecret, accountId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get latest market data of option strategy
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public getOptionsStrategyQuote(userId: string, userSecret: string, accountId: string, optionStrategyId: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).getOptionsStrategyQuote(userId, userSecret, accountId, optionStrategyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the options holdings in the account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public listOptionHoldings(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).listOptionHoldings(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an option strategy order on the brokerage
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} optionStrategyId Option strategy id obtained from response when creating option strategy object
     * @param {OptionsPlaceOptionStrategyRequest} optionsPlaceOptionStrategyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public placeOptionStrategy(userId: string, userSecret: string, accountId: string, optionStrategyId: string, optionsPlaceOptionStrategyRequest: OptionsPlaceOptionStrategyRequest, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).placeOptionStrategy(userId, userSecret, accountId, optionStrategyId, optionsPlaceOptionStrategyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortfolioManagementApi - axios parameter creator
 * @export
 */
export const PortfolioManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioExcludedAsset: async (portfolioGroupId: string, universalSymbol?: UniversalSymbol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('addPortfolioExcludedAsset', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(universalSymbol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (userId: string, userSecret: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('create', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('create', 'userSecret', userSecret)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('create', 'requestBody', requestBody)
            const localVarPath = `/portfolioGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetClass: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelAssetClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelPortfolio: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelPortfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetClass: async (modelAssetClassId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('deleteAssetClass', 'modelAssetClassId', modelAssetClassId)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExcludedAsset: async (portfolioGroupId: string, symbolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('deleteExcludedAsset', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'symbolId' is not null or undefined
            assertParamExists('deleteExcludedAsset', 'symbolId', symbolId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets/{symbolId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"symbolId"}}`, encodeURIComponent(String(symbolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelPortfolioById: async (modelPortfolioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('deleteModelPortfolioById', 'modelPortfolioId', modelPortfolioId)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfoli: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('deletePortfoli', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioTargetById: async (portfolioGroupId: string, targetAssetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('deletePortfolioTargetById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('deletePortfolioTargetById', 'targetAssetId', targetAssetId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailAssetClass: async (modelAssetClassId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('detailAssetClass', 'modelAssetClassId', modelAssetClassId)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradeById: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getCalculatedTradeById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('getCalculatedTradeById', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getCalculatedTradeById', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/{TradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"TradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDetailsById: async (modelPortfolioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('getModelDetailsById', 'modelPortfolioId', modelPortfolioId)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioBalances: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioBalances', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/balances`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioDetailsById: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioDetailsById', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioInfo: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioInfo', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/info`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPositions: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioPositions', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/positions`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioSettings: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioSettings', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/settings`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioTargetById: async (portfolioGroupId: string, targetAssetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioTargetById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('getPortfolioTargetById', 'targetAssetId', targetAssetId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioTargets: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortfolioTargets', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group\\
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortoflioExcludedAssets: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getPortoflioExcludedAssets', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importModelPortfolio: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('importModelPortfolio', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/import`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('list', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('list', 'userSecret', userSecret)
            const localVarPath = `/portfolioGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetClasses: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelAssetClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalculatedTrades: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('listCalculatedTrades', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelPortfolio: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelPortfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioAccounts: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('listPortfolioAccounts', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/accounts`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyModelPortfolioById: async (modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('modifyModelPortfolioById', 'modelPortfolioId', modelPortfolioId)
            // verify required parameter 'modelPortfolioDetails' is not null or undefined
            assertParamExists('modifyModelPortfolioById', 'modelPortfolioDetails', modelPortfolioDetails)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelPortfolioDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePortfolio: async (portfolioGroupId: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('savePortfolio', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('savePortfolio', 'requestBody', requestBody)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortfolioSymbols: async (portfolioGroupId: string, symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('searchPortfolioSymbols', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/symbols`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPortfolioTargets: async (portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('setPortfolioTargets', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetClass: async (modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('updateAssetClass', 'modelAssetClassId', modelAssetClassId)
            // verify required parameter 'modelAssetClassDetails' is not null or undefined
            assertParamExists('updateAssetClass', 'modelAssetClassDetails', modelAssetClassDetails)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelAssetClassDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioSettings: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('updatePortfolioSettings', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/settings`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioTargetById: async (portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('updatePortfolioTargetById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('updatePortfolioTargetById', 'targetAssetId', targetAssetId)
            // verify required parameter 'targetAsset' is not null or undefined
            assertParamExists('updatePortfolioTargetById', 'targetAsset', targetAsset)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioManagementApi - functional programming interface
 * @export
 */
export const PortfolioManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPortfolioExcludedAsset(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExcludedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPortfolioExcludedAsset(portfolioGroupId, universalSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(userId, userSecret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetClass(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAssetClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetClass(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModelPortfolio(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelPortfolioDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModelPortfolio(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetClass(modelAssetClassId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetClass(modelAssetClassId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExcludedAsset(portfolioGroupId: string, symbolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExcludedAsset(portfolioGroupId, symbolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModelPortfolioById(modelPortfolioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModelPortfolioById(modelPortfolioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePortfoli(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePortfoli(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePortfolioTargetById(portfolioGroupId, targetAssetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detailAssetClass(modelAssetClassId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAssetClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detailAssetClass(modelAssetClassId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModelDetailsById(modelPortfolioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelPortfolioDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModelDetailsById(modelPortfolioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioBalances(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioBalances(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioDetailsById(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioDetailsById(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioInfo(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioInfo(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioPositions(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroupPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioPositions(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioSettings(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioSettings(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioTargetById(portfolioGroupId, targetAssetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortfolioTargets(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortfolioTargets(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group\\
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPortoflioExcludedAssets(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExcludedAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPortoflioExcludedAssets(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importModelPortfolio(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importModelPortfolio(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAssetClasses(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelAssetClassDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAssetClasses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCalculatedTrades(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculatedTrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCalculatedTrades(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModelPortfolio(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelPortfolioDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModelPortfolio(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPortfolioAccounts(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPortfolioAccounts(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyModelPortfolioById(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyModelPortfolioById(modelPortfolioId, modelPortfolioDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savePortfolio(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.savePortfolio(portfolioGroupId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPortfolioSymbols(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPortfolioSymbols(portfolioGroupId, symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPortfolioTargets(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPortfolioTargets(portfolioGroupId, targetAsset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssetClass(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssetClass(modelAssetClassId, modelAssetClassDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePortfolioSettings(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePortfolioSettings(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePortfolioTargetById(portfolioGroupId, targetAssetId, targetAsset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortfolioManagementApi - factory interface
 * @export
 */
export const PortfolioManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPortfolioExcludedAsset(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: any): AxiosPromise<ExcludedAsset> {
            return localVarFp.addPortfolioExcludedAsset(portfolioGroupId, universalSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<Array<PortfolioGroup>> {
            return localVarFp.create(userId, userSecret, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetClass(options?: any): AxiosPromise<ModelAssetClassDetails> {
            return localVarFp.createAssetClass(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModelPortfolio(options?: any): AxiosPromise<ModelPortfolioDetails> {
            return localVarFp.createModelPortfolio(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetClass(modelAssetClassId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAssetClass(modelAssetClassId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExcludedAsset(portfolioGroupId: string, symbolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteExcludedAsset(portfolioGroupId, symbolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModelPortfolioById(modelPortfolioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteModelPortfolioById(modelPortfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfoli(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.deletePortfoli(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.deletePortfolioTargetById(portfolioGroupId, targetAssetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detailAssetClass(modelAssetClassId: string, options?: any): AxiosPromise<ModelAssetClassDetails> {
            return localVarFp.detailAssetClass(modelAssetClassId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: any): AxiosPromise<Array<Trade>> {
            return localVarFp.getCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModelDetailsById(modelPortfolioId: string, options?: any): AxiosPromise<ModelPortfolioDetails> {
            return localVarFp.getModelDetailsById(modelPortfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioBalances(portfolioGroupId: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.getPortfolioBalances(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioDetailsById(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.getPortfolioDetailsById(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioInfo(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupInfo> {
            return localVarFp.getPortfolioInfo(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioPositions(portfolioGroupId: string, options?: any): AxiosPromise<Array<PortfolioGroupPosition>> {
            return localVarFp.getPortfolioPositions(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioSettings(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupSettings> {
            return localVarFp.getPortfolioSettings(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.getPortfolioTargetById(portfolioGroupId, targetAssetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortfolioTargets(portfolioGroupId: string, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.getPortfolioTargets(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group\\
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPortoflioExcludedAssets(portfolioGroupId: string, options?: any): AxiosPromise<Array<ExcludedAsset>> {
            return localVarFp.getPortoflioExcludedAssets(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importModelPortfolio(portfolioGroupId: string, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.importModelPortfolio(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(userId: string, userSecret: string, options?: any): AxiosPromise<Array<PortfolioGroup>> {
            return localVarFp.list(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAssetClasses(options?: any): AxiosPromise<Array<ModelAssetClassDetails>> {
            return localVarFp.listAssetClasses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCalculatedTrades(portfolioGroupId: string, options?: any): AxiosPromise<CalculatedTrade> {
            return localVarFp.listCalculatedTrades(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModelPortfolio(options?: any): AxiosPromise<Array<ModelPortfolioDetails>> {
            return localVarFp.listModelPortfolio(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPortfolioAccounts(portfolioGroupId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.listPortfolioAccounts(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyModelPortfolioById(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: any): AxiosPromise<void> {
            return localVarFp.modifyModelPortfolioById(modelPortfolioId, modelPortfolioDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savePortfolio(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.savePortfolio(portfolioGroupId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPortfolioSymbols(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.searchPortfolioSymbols(portfolioGroupId, symbolQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPortfolioTargets(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.setPortfolioTargets(portfolioGroupId, targetAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetClass(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: any): AxiosPromise<void> {
            return localVarFp.updateAssetClass(modelAssetClassId, modelAssetClassDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioSettings(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupSettings> {
            return localVarFp.updatePortfolioSettings(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.updatePortfolioTargetById(portfolioGroupId, targetAssetId, targetAsset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioManagementApi - object-oriented interface
 * @export
 * @class PortfolioManagementApi
 * @extends {BaseAPI}
 */
export class PortfolioManagementApi extends BaseAPI {
    /**
     * 
     * @summary Adds an asset to exclude to a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
     * @param {UniversalSymbol} [universalSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public addPortfolioExcludedAsset(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).addPortfolioExcludedAsset(portfolioGroupId, universalSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new portfolio group
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public create(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).create(userId, userSecret, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new model asset class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public createAssetClass(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).createAssetClass(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new model portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public createModelPortfolio(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).createModelPortfolio(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a model asset class
     * @param {string} modelAssetClassId The ID of the model asset class to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public deleteAssetClass(modelAssetClassId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).deleteAssetClass(modelAssetClassId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unexclude an asset from a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
     * @param {string} symbolId The ID of the excluded asset Symbol to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public deleteExcludedAsset(portfolioGroupId: string, symbolId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).deleteExcludedAsset(portfolioGroupId, symbolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a model portfolio
     * @param {string} modelPortfolioId The ID of the model portfolio to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public deleteModelPortfolioById(modelPortfolioId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).deleteModelPortfolioById(modelPortfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a target portfolio.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public deletePortfoli(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).deletePortfoli(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a TargetAsset.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public deletePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).deletePortfolioTargetById(portfolioGroupId, targetAssetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a model asset class
     * @param {string} modelAssetClassId The ID of the model asset class to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public detailAssetClass(modelAssetClassId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).detailAssetClass(modelAssetClassId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return an individual trade
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a model portfolio
     * @param {string} modelPortfolioId The ID of the model portfolio to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getModelDetailsById(modelPortfolioId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getModelDetailsById(modelPortfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sum of cash balances in portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioBalances(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioBalances(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a target portfolio
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioDetailsById(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioDetailsById(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a whole bunch of relevant information relating to a portfolio group.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioInfo(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioInfo(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get total of each postions owned in portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioPositions(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioPositions(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get portfolio group settings
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioSettings(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioSettings(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific target from a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioTargetById(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioTargetById(portfolioGroupId, targetAssetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all target assets under the specified PortfolioGroup.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortfolioTargets(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortfolioTargets(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an array of excluded assets associated with a portfolio group\\
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public getPortoflioExcludedAssets(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).getPortoflioExcludedAssets(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import target allocation based on portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public importModelPortfolio(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).importModelPortfolio(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all portfolio groups
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public list(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).list(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of model asset class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public listAssetClasses(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).listAssetClasses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of trades to make to rebalance portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public listCalculatedTrades(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).listCalculatedTrades(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of model portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public listModelPortfolio(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).listModelPortfolio(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all accounts associated with a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public listPortfolioAccounts(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).listPortfolioAccounts(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates model portfolio object
     * @param {string} modelPortfolioId The ID of the model portfolio to update.
     * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modifyModelPortfolioById(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modifyModelPortfolioById(modelPortfolioId, modelPortfolioDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing target portfolio.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public savePortfolio(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).savePortfolio(portfolioGroupId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for symbols limited to brokerages under the specified portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public searchPortfolioSymbols(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).searchPortfolioSymbols(portfolioGroupId, symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {Array<TargetAsset>} [targetAsset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public setPortfolioTargets(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).setPortfolioTargets(portfolioGroupId, targetAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates model asset class objects
     * @param {string} modelAssetClassId The ID of the model asset class to update.
     * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public updateAssetClass(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).updateAssetClass(modelAssetClassId, modelAssetClassDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates portfolio group settings
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public updatePortfolioSettings(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).updatePortfolioSettings(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a TargetAsset under the specified PortfolioGroup.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to patch.
     * @param {TargetAsset} targetAsset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public updatePortfolioTargetById(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).updatePortfolioTargetById(portfolioGroupId, targetAssetId, targetAsset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferenceDataApi - axios parameter creator
 * @export
 */
export const ReferenceDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyExchangeRatePair: async (currencyPair: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyPair' is not null or undefined
            assertParamExists('getCurrencyExchangeRatePair', 'currencyPair', currencyPair)
            const localVarPath = `/currencies/rates/{currencyPair}`
                .replace(`{${"currencyPair"}}`, encodeURIComponent(String(currencyPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapTrade/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/securityTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockExchanges: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbols: async (symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/symbols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {string} [symbolId] OPTIONAL IN PATH Can be used instead of the ticker ; The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolsByTicker: async (ticker: string, symbolId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getSymbolsByTicker', 'ticker', ticker)
            const localVarPath = `/symbols/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (symbolId !== undefined) {
                localVarQueryParameter['symbolId'] = symbolId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBrokerageAuthorizationType: async (brokerage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerageAuthorizationTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (brokerage !== undefined) {
                localVarQueryParameter['brokerage'] = brokerage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBrokerages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCurrencies: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCurrenciesRates: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolSearchUserAccount: async (userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('symbolSearchUserAccount', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('symbolSearchUserAccount', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('symbolSearchUserAccount', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/symbols`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceDataApi - functional programming interface
 * @export
 */
export const ReferenceDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferenceDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencyExchangeRatePair(currencyPair: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeRatePairs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencyExchangeRatePair(currencyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartnerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartnerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecurityTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecurityType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecurityTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockExchanges(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Exchange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockExchanges(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbols(symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSymbols(symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {string} [symbolId] OPTIONAL IN PATH Can be used instead of the ticker ; The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbolsByTicker(ticker: string, symbolId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniversalSymbol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSymbolsByTicker(ticker, symbolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllBrokerageAuthorizationType(brokerage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrokerageAuthorizationTypeReadOnly>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllBrokerageAuthorizationType(brokerage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllBrokerages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brokerage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllBrokerages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllCurrencies(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Currency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllCurrencies(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllCurrenciesRates(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExchangeRatePairs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllCurrenciesRates(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async symbolSearchUserAccount(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.symbolSearchUserAccount(userId, userSecret, accountId, symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferenceDataApi - factory interface
 * @export
 */
export const ReferenceDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferenceDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyExchangeRatePair(currencyPair: string, options?: any): AxiosPromise<ExchangeRatePairs> {
            return localVarFp.getCurrencyExchangeRatePair(currencyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartnerInfo(options?: any): AxiosPromise<PartnerData> {
            return localVarFp.getPartnerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecurityTypes(options?: any): AxiosPromise<Array<SecurityType>> {
            return localVarFp.getSecurityTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockExchanges(options?: any): AxiosPromise<Array<Exchange>> {
            return localVarFp.getStockExchanges(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbols(symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.getSymbols(symbolQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {string} [symbolId] OPTIONAL IN PATH Can be used instead of the ticker ; The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolsByTicker(ticker: string, symbolId?: string, options?: any): AxiosPromise<UniversalSymbol> {
            return localVarFp.getSymbolsByTicker(ticker, symbolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBrokerageAuthorizationType(brokerage?: string, options?: any): AxiosPromise<Array<BrokerageAuthorizationTypeReadOnly>> {
            return localVarFp.listAllBrokerageAuthorizationType(brokerage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllBrokerages(options?: any): AxiosPromise<Array<Brokerage>> {
            return localVarFp.listAllBrokerages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCurrencies(options?: any): AxiosPromise<Array<Currency>> {
            return localVarFp.listAllCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllCurrenciesRates(options?: any): AxiosPromise<Array<ExchangeRatePairs>> {
            return localVarFp.listAllCurrenciesRates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolSearchUserAccount(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.symbolSearchUserAccount(userId, userSecret, accountId, symbolQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferenceDataApi - object-oriented interface
 * @export
 * @class ReferenceDataApi
 * @extends {BaseAPI}
 */
export class ReferenceDataApi extends BaseAPI {
    /**
     * 
     * @summary Return the exchange rate of a currency pair
     * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getCurrencyExchangeRatePair(currencyPair: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getCurrencyExchangeRatePair(currencyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata related to Snaptrade partner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getPartnerInfo(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getPartnerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all security types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getSecurityTypes(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getSecurityTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return list of stock exchanges on Passiv and their suffixes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getStockExchanges(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getStockExchanges(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for symbols
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getSymbols(symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getSymbols(symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a symbol by the ticker
     * @param {string} ticker The ticker of the UniversalSymbol to get.
     * @param {string} [symbolId] OPTIONAL IN PATH Can be used instead of the ticker ; The ID of the UniversalSymbol to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public getSymbolsByTicker(ticker: string, symbolId?: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).getSymbolsByTicker(ticker, symbolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all brokerage authorization types
     * @param {string} [brokerage] Comma separated value of brokerage slugs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public listAllBrokerageAuthorizationType(brokerage?: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).listAllBrokerageAuthorizationType(brokerage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all brokerages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public listAllBrokerages(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).listAllBrokerages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all supported currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public listAllCurrencies(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).listAllCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the exchange rates of all supported currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public listAllCurrenciesRates(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).listAllCurrenciesRates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for symbols that are supported by a brokerage account using a substring
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public symbolSearchUserAccount(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).symbolSearchUserAccount(userId, userSecret, accountId, symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUserAccountOrder: async (userId: string, userSecret: string, accountId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('cancelUserAccountOrder', 'body', body)
            const localVarPath = `/accounts/{accountId}/orders/cancel`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradeImpactById: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getCalculatedTradeImpactById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('getCalculatedTradeImpactById', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('getCalculatedTradeImpactById', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradesImpact: async (portfolioGroupId: string, calculatedTradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('getCalculatedTradesImpact', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('getCalculatedTradesImpact', 'calculatedTradeId', calculatedTradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/impact`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact: async (userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getOrderImpact', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getOrderImpact', 'userSecret', userSecret)
            // verify required parameter 'manualTradeForm' is not null or undefined
            assertParamExists('getOrderImpact', 'manualTradeForm', manualTradeForm)
            const localVarPath = `/trade/impact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes: async (userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'userSecret', userSecret)
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'symbols', symbols)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getUserAccountQuotes', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/quotes`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (useTicker !== undefined) {
                localVarQueryParameter['use_ticker'] = useTicker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCalculatedTradeById: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('modifyCalculatedTradeById', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('modifyCalculatedTradeById', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('modifyCalculatedTradeById', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCalculatedTrades: async (portfolioGroupId: string, calculatedTradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('placeCalculatedTrades', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('placeCalculatedTrades', 'calculatedTradeId', calculatedTradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/placeOrders`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place a trade with NO validation.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder: async (userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeForceOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeForceOrder', 'userSecret', userSecret)
            // verify required parameter 'manualTradeForm' is not null or undefined
            assertParamExists('placeForceOrder', 'manualTradeForm', manualTradeForm)
            const localVarPath = `/trade/place`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradingPlaceOCOOrderRequest} tradingPlaceOCOOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOCOOrder: async (userId: string, userSecret: string, tradingPlaceOCOOrderRequest: TradingPlaceOCOOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeOCOOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeOCOOrder', 'userSecret', userSecret)
            // verify required parameter 'tradingPlaceOCOOrderRequest' is not null or undefined
            assertParamExists('placeOCOOrder', 'tradingPlaceOCOOrderRequest', tradingPlaceOCOOrderRequest)
            const localVarPath = `/trade/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tradingPlaceOCOOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: async (tradeId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('placeOrder', 'tradeId', tradeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('placeOrder', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('placeOrder', 'userSecret', userSecret)
            const localVarPath = `/trade/{tradeId}`
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelUserAccountOrder(userId: string, userSecret: string, accountId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelUserAccountOrder(userId, userSecret, accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalculatedTradeImpactById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalculatedTradeImpactById(portfolioGroupId, calculatedTradeId, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalculatedTradesImpact(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeImpact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalculatedTradesImpact(portfolioGroupId, calculatedTradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderImpact(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualTradeAndImpact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderImpact(userId, userSecret, manualTradeForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountQuotes(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SymbolsQuotes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountQuotes(userId, userSecret, symbols, accountId, useTicker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, trade, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeCalculatedTrades(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeExecutionStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeCalculatedTrades(portfolioGroupId, calculatedTradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place a trade with NO validation.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeForceOrder(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeForceOrder(userId, userSecret, manualTradeForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradingPlaceOCOOrderRequest} tradingPlaceOCOOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOCOOrder(userId: string, userSecret: string, tradingPlaceOCOOrderRequest: TradingPlaceOCOOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOCOOrder(userId, userSecret, tradingPlaceOCOOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOrder(tradeId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOrder(tradeId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUserAccountOrder(userId: string, userSecret: string, accountId: string, body: string, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.cancelUserAccountOrder(userId, userSecret, accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradeImpactById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.getCalculatedTradeImpactById(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculatedTradesImpact(portfolioGroupId: string, calculatedTradeId: string, options?: any): AxiosPromise<Array<TradeImpact>> {
            return localVarFp.getCalculatedTradesImpact(portfolioGroupId, calculatedTradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderImpact(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: any): AxiosPromise<ManualTradeAndImpact> {
            return localVarFp.getOrderImpact(userId, userSecret, manualTradeForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountQuotes(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: any): AxiosPromise<SymbolsQuotes> {
            return localVarFp.getUserAccountQuotes(userId, userSecret, symbols, accountId, useTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: any): AxiosPromise<Trade> {
            return localVarFp.modifyCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCalculatedTrades(portfolioGroupId: string, calculatedTradeId: string, options?: any): AxiosPromise<Array<TradeExecutionStatus>> {
            return localVarFp.placeCalculatedTrades(portfolioGroupId, calculatedTradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place a trade with NO validation.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeForceOrder(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.placeForceOrder(userId, userSecret, manualTradeForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradingPlaceOCOOrderRequest} tradingPlaceOCOOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOCOOrder(userId: string, userSecret: string, tradingPlaceOCOOrderRequest: TradingPlaceOCOOrderRequest, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.placeOCOOrder(userId, userSecret, tradingPlaceOCOOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(tradeId: string, userId: string, userSecret: string, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.placeOrder(tradeId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * 
     * @summary Cancel open order in account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public cancelUserAccountOrder(userId: string, userSecret: string, accountId: string, body: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).cancelUserAccountOrder(userId, userSecret, accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return details of a specific trade before it\'s placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getCalculatedTradeImpactById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getCalculatedTradeImpactById(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the impact of placing a series of trades on the portfolio
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getCalculatedTradesImpact(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getCalculatedTradesImpact(portfolioGroupId, calculatedTradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check impact of trades on account.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {ManualTradeForm} manualTradeForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getOrderImpact(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getOrderImpact(userId, userSecret, manualTradeForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get symbol quotes
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
     * @param {string} accountId The ID of the account to get quotes.
     * @param {boolean} [useTicker] Should be set to True if providing tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public getUserAccountQuotes(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).getUserAccountQuotes(userId, userSecret, symbols, accountId, useTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify units of a trade before it is placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {Trade} [trade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public modifyCalculatedTradeById(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).modifyCalculatedTradeById(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place orders for the CalculatedTrades in series
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public placeCalculatedTrades(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeCalculatedTrades(portfolioGroupId, calculatedTradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place a trade with NO validation.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {ManualTradeForm} manualTradeForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public placeForceOrder(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeForceOrder(userId, userSecret, manualTradeForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place a OCO (One Cancels Other) order
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {TradingPlaceOCOOrderRequest} tradingPlaceOCOOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public placeOCOOrder(userId: string, userSecret: string, tradingPlaceOCOOrderRequest: TradingPlaceOCOOrderRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeOCOOrder(userId, userSecret, tradingPlaceOCOOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place order
     * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public placeOrder(tradeId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).placeOrder(tradeId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsAndReportingApi - axios parameter creator
 * @export
 */
export const TransactionsAndReportingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getActivities', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getActivities', 'userSecret', userSecret)
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportingCustomRange: async (startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getReportingCustomRange', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getReportingCustomRange', 'endDate', endDate)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getReportingCustomRange', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('getReportingCustomRange', 'userSecret', userSecret)
            const localVarPath = `/performance/custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (detailed !== undefined) {
                localVarQueryParameter['detailed'] = detailed;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsAndReportingApi - functional programming interface
 * @export
 */
export const TransactionsAndReportingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsAndReportingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(userId, userSecret, startDate, endDate, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportingCustomRange(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerformanceCustom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportingCustomRange(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsAndReportingApi - factory interface
 * @export
 */
export const TransactionsAndReportingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsAndReportingApiFp(configuration)
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: any): AxiosPromise<Array<UniversalActivity>> {
            return localVarFp.getActivities(userId, userSecret, startDate, endDate, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportingCustomRange(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: any): AxiosPromise<PerformanceCustom> {
            return localVarFp.getReportingCustomRange(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsAndReportingApi - object-oriented interface
 * @export
 * @class TransactionsAndReportingApi
 * @extends {BaseAPI}
 */
export class TransactionsAndReportingApi extends BaseAPI {
    /**
     * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
     * @summary Get transaction history for a user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsAndReportingApi
     */
    public getActivities(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: AxiosRequestConfig) {
        return TransactionsAndReportingApiFp(this.configuration).getActivities(userId, userSecret, startDate, endDate, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
     * @summary Get performance information for a specific timeframe
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
     * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
     * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsAndReportingApi
     */
    public getReportingCustomRange(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: AxiosRequestConfig) {
        return TransactionsAndReportingApiFp(this.configuration).getReportingCustomRange(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options).then((request) => request(this.axios, this.basePath));
    }
}


