/* tslint:disable */
/* eslint-disable */
/**
 * SnapTrade
 * Connect brokerage accounts to your app for live positions and trading
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api@snaptrade.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * https://konfigthis.com
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * SnapTradeUser Investment Account
 * @export
 * @interface Account
 */
export interface Account {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'brokerage_authorization'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'portfolio_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'institution_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'created_date'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof Account
     */
    'meta'?: { [key: string]: any; };
    /**
     * 
     * @type {Array<CashRestriction>}
     * @memberof Account
     */
    'cash_restrictions'?: Array<CashRestriction>;
}
/**
 * Account Holdings
 * @export
 * @interface AccountHoldings
 */
export interface AccountHoldings {
    [key: string]: any;

    /**
     * 
     * @type {SnapTradeHoldingsAccount}
     * @memberof AccountHoldings
     */
    'account'?: SnapTradeHoldingsAccount;
    /**
     * 
     * @type {Array<Balance>}
     * @memberof AccountHoldings
     */
    'balances'?: Array<Balance>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof AccountHoldings
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {SnapTradeHoldingsTotalValue}
     * @memberof AccountHoldings
     */
    'total_value'?: SnapTradeHoldingsTotalValue;
}
/**
 * Record of order in brokerageaccount
 * @export
 * @interface AccountOrderRecord
 */
export interface AccountOrderRecord {
    [key: string]: any;

    /**
     * Order id returned by brokerage
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'brokerage_order_id'?: string;
    /**
     * 
     * @type {AccountOrderRecordStatus}
     * @memberof AccountOrderRecord
     */
    'status'?: AccountOrderRecordStatus;
    /**
     * 
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'symbol'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof AccountOrderRecord
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {Action}
     * @memberof AccountOrderRecord
     */
    'action'?: Action;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'total_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'open_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'canceled_quantity'?: number;
    /**
     * Trade Units
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'filled_quantity'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'execution_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'limit_price'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof AccountOrderRecord
     */
    'stop_price'?: number;
    /**
     * 
     * @type {OrderType}
     * @memberof AccountOrderRecord
     */
    'order_type'?: OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof AccountOrderRecord
     */
    'time_in_force'?: TimeInForce;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'time_placed'?: string;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'time_updated'?: string;
    /**
     * Time
     * @type {string}
     * @memberof AccountOrderRecord
     */
    'expiry_date'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccountOrderRecordStatus = {
    None: 'NONE',
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Failed: 'FAILED',
    Rejected: 'REJECTED',
    Canceled: 'CANCELED',
    PartialCanceled: 'PARTIAL_CANCELED',
    CancelPending: 'CANCEL_PENDING',
    Executed: 'EXECUTED',
    Partial: 'PARTIAL',
    ReplacePending: 'REPLACE_PENDING',
    Replaced: 'REPLACED',
    Stopped: 'STOPPED',
    Suspended: 'SUSPENDED',
    Expired: 'EXPIRED',
    Queued: 'QUEUED',
    Triggered: 'TRIGGERED',
    Activated: 'ACTIVATED',
    PendingRiskReview: 'PENDING_RISK_REVIEW',
    ContingentOrder: 'CONTINGENT_ORDER'
} as const;

export type AccountOrderRecordStatus = typeof AccountOrderRecordStatus[keyof typeof AccountOrderRecordStatus];


/**
 * SnapTradeUser Investment Account
 * @export
 * @interface AccountSimple
 */
export interface AccountSimple {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSimple
     */
    'number'?: string;
}
/**
 * Trade Action
 * @export
 * @enum {string}
 */

export const Action = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type Action = typeof Action[keyof typeof Action];


/**
 * Account Balance
 * @export
 * @interface Balance
 */
export interface Balance {
    [key: string]: any;

    /**
     * 
     * @type {Currency}
     * @memberof Balance
     */
    'currency'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    'cash'?: number;
}
/**
 * 
 * @export
 * @interface Brokerage
 */
export interface Brokerage {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'aws_s3_logo_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'maintenance_mode'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_fractional_units'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_trading'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'has_reporting'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'is_real_time_connection'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'allows_trading_through_snaptrade_api'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'is_scraping_integration'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'default_currency'?: string;
    /**
     * 
     * @type {BrokerageType}
     * @memberof Brokerage
     */
    'brokerage_type'?: BrokerageType;
    /**
     * List of exchange ID supported by brokerage
     * @type {Array<any>}
     * @memberof Brokerage
     */
    'exchanges'?: Array<any>;
}
/**
 * 
 * @export
 * @interface BrokerageAuthorization
 */
export interface BrokerageAuthorization {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'id'?: string;
    /**
     * Time
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'created_date'?: string;
    /**
     * Time
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'updated_date'?: string;
    /**
     * 
     * @type {Brokerage}
     * @memberof BrokerageAuthorization
     */
    'brokerage'?: Brokerage;
    /**
     * Connection Name
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BrokerageAuthorization
     */
    'disabled'?: boolean;
    /**
     * Disabled date
     * @type {string}
     * @memberof BrokerageAuthorization
     */
    'disabled_date'?: string | null;
    /**
     * Additional data about brokerage authorization
     * @type {{ [key: string]: any; }}
     * @memberof BrokerageAuthorization
     */
    'meta'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface BrokerageAuthorizationType
 */
export interface BrokerageAuthorizationType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationType
     */
    'type'?: BrokerageAuthorizationTypeTypeEnum;
}

export const BrokerageAuthorizationTypeTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type BrokerageAuthorizationTypeTypeEnum = typeof BrokerageAuthorizationTypeTypeEnum[keyof typeof BrokerageAuthorizationTypeTypeEnum];

/**
 * 
 * @export
 * @interface BrokerageAuthorizationTypeReadOnly
 */
export interface BrokerageAuthorizationTypeReadOnly {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'type'?: BrokerageAuthorizationTypeReadOnlyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'auth_type'?: BrokerageAuthorizationTypeReadOnlyAuthTypeEnum;
    /**
     * 
     * @type {BrokerageAuthorizationTypeReadOnlyBrokerage}
     * @memberof BrokerageAuthorizationTypeReadOnly
     */
    'brokerage'?: BrokerageAuthorizationTypeReadOnlyBrokerage;
}

export const BrokerageAuthorizationTypeReadOnlyTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type BrokerageAuthorizationTypeReadOnlyTypeEnum = typeof BrokerageAuthorizationTypeReadOnlyTypeEnum[keyof typeof BrokerageAuthorizationTypeReadOnlyTypeEnum];
export const BrokerageAuthorizationTypeReadOnlyAuthTypeEnum = {
    Oauth: 'OAUTH',
    Scrape: 'SCRAPE',
    UnofficialApi: 'UNOFFICIAL_API',
    Token: 'TOKEN'
} as const;

export type BrokerageAuthorizationTypeReadOnlyAuthTypeEnum = typeof BrokerageAuthorizationTypeReadOnlyAuthTypeEnum[keyof typeof BrokerageAuthorizationTypeReadOnlyAuthTypeEnum];

/**
 * 
 * @export
 * @interface BrokerageAuthorizationTypeReadOnlyBrokerage
 */
export interface BrokerageAuthorizationTypeReadOnlyBrokerage {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'id'?: string;
    /**
     * Name of Brokerage
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'name'?: string;
    /**
     * Slug of Brokerage. It is usually the name of the brokerage in capital letters
     * @type {string}
     * @memberof BrokerageAuthorizationTypeReadOnlyBrokerage
     */
    'slug'?: string;
}
/**
 * Brokerage symbol
 * @export
 * @interface BrokerageSymbol
 */
export interface BrokerageSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof BrokerageSymbol
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {BrokerageAuthorization}
     * @memberof BrokerageSymbol
     */
    'brokerage_authorization'?: BrokerageAuthorization;
    /**
     * 
     * @type {string}
     * @memberof BrokerageSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BrokerageSymbol
     */
    'allows_fractional_units'?: boolean;
}
/**
 * Type of brokerage
 * @export
 * @interface BrokerageType
 */
export interface BrokerageType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof BrokerageType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrokerageType
     */
    'name'?: string;
}
/**
 * Array of trades to make to rebalance portfolio
 * @export
 * @interface CalculatedTrade
 */
export interface CalculatedTrade {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CalculatedTrade
     */
    'id'?: string;
    /**
     * 
     * @type {Array<Trade>}
     * @memberof CalculatedTrade
     */
    'trades'?: Array<Trade>;
}
/**
 * Cash restriction rules that apply to this account when undergoing portfolio rebalance calculations.
 * @export
 * @interface CashRestriction
 */
export interface CashRestriction {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashRestriction
     */
    'type'?: CashRestrictionTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CashRestriction
     */
    'amount'?: number;
}

export const CashRestrictionTypeEnum = {
    AllocateMax: 'ALLOCATE_MAX',
    RetainMin: 'RETAIN_MIN'
} as const;

export type CashRestrictionTypeEnum = typeof CashRestrictionTypeEnum[keyof typeof CashRestrictionTypeEnum];

/**
 * Currency
 * @export
 * @interface Currency
 */
export interface Currency {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
}
/**
 * Response when delete user is successful
 * @export
 * @interface DeleteUserResponse
 */
export interface DeleteUserResponse {
    [key: string]: any;

    /**
     * Delete status
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'status'?: string;
    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof DeleteUserResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface DividendAtDate
 */
export interface DividendAtDate {
    [key: string]: any;

    /**
     * The ticker of the symbol that the dividend came from
     * @type {string}
     * @memberof DividendAtDate
     */
    'symbol'?: string;
    /**
     * The amount received from the dividend
     * @type {number}
     * @memberof DividendAtDate
     */
    'amount'?: number;
    /**
     * The currency of the amount
     * @type {string}
     * @memberof DividendAtDate
     */
    'currency'?: string;
}
/**
 * This response consists of 2 different components that must be decrypted to obtain the decrypted message  * Decrypting the encryptedSharedKey    The encrypted shared key is a shared key that was randomly generated by SnapTrade and encrypted using the users SSH public key provided when registering the user   It is needed to decrypt the message in step 2.    To decrypt the shared key, the user should have access to their SSH private key stored locally in their device    An example Python code on how to decrypt the shared key is shown below    ```   def decrypt_rsa_message(self, encrypted_message):       from Crypto.Cipher import PKCS1_OAEP       from Crypto.PublicKey import RSA       from base64 import b64decode        f = open(\'private.pem\', \'r\')       private_key = RSA.import_key(f.read())       cipher = PKCS1_OAEP.new(private_key)        return cipher.decrypt(b64decode(encrypted_message.encode())).decode()   ```  * Decrypting the encryptedMessageData     The data meant to be returned by an endpoint can be obtained by decrypting the encrypted message     An encrypted message is a message that is encrypted using AES - MODE OCB with the shared key obtained in step one    An example code to decrypt the encrypted message is shown below    ```   def decrypt_aes_message(self, shared_key, encrypted_message):       from Crypto.Cipher import AES       from base64 import b64decode        encrypted_msg = b64decode(encrypted_message[\"encryptedMessage\"].encode())       tag = b64decode(encrypted_message[\"tag\"].encode())       nonce = b64decode(encrypted_message[\"nonce\"].encode())       cipher = AES.new(shared_key.encode(), AES.MODE_OCB, nonce=nonce)        return cipher.decrypt_and_verify(encrypted_msg, tag).decode()   ``` 
 * @export
 * @interface EncryptedResponse
 */
export interface EncryptedResponse {
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponse
     */
    'encryptedSharedKey'?: string;
    /**
     * 
     * @type {EncryptedResponseEncryptedMessageData}
     * @memberof EncryptedResponse
     */
    'encryptedMessageData'?: EncryptedResponseEncryptedMessageData;
}
/**
 * 
 * @export
 * @interface EncryptedResponseEncryptedMessageData
 */
export interface EncryptedResponseEncryptedMessageData {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'encryptedMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof EncryptedResponseEncryptedMessageData
     */
    'nonce'?: string;
}
/**
 * Stock Exchange
 * @export
 * @interface Exchange
 */
export interface Exchange {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'close_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exchange
     */
    'suffix'?: string;
}
/**
 * The exchange rate of a pair of currencies
 * @export
 * @interface ExchangeRatePairs
 */
export interface ExchangeRatePairs {
    [key: string]: any;

    /**
     * 
     * @type {Currency}
     * @memberof ExchangeRatePairs
     */
    'src'?: Currency;
    /**
     * 
     * @type {Currency}
     * @memberof ExchangeRatePairs
     */
    'dst'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof ExchangeRatePairs
     */
    'exchange_rate'?: number;
}
/**
 * An excluded asset in a portfolio group
 * @export
 * @interface ExcludedAsset
 */
export interface ExcludedAsset {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ExcludedAsset
     */
    'symbol'?: UniversalSymbol;
}
/**
 * JWT Token. Used to acess resources in private endpoints available only through the Passiv app
 * @export
 * @interface JWT
 */
export interface JWT {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof JWT
     */
    'token'?: string;
}
/**
 * Redirect uri upon successful login
 * @export
 * @interface LoginRedirectURI
 */
export interface LoginRedirectURI {
    /**
     * 
     * @type {any}
     * @memberof LoginRedirectURI
     */
    'redirectURI'?: any;
    /**
     * 
     * @type {string}
     * @memberof LoginRedirectURI
     */
    'sessionId'?: string;
}
/**
 * A manual trade object
 * @export
 * @interface ManualTrade
 */
export interface ManualTrade {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ManualTrade
     */
    'id'?: string;
    /**
     * 
     * @type {Account}
     * @memberof ManualTrade
     */
    'account'?: Account;
    /**
     * 
     * @type {OrderType}
     * @memberof ManualTrade
     */
    'order_type'?: OrderType;
    /**
     * 
     * @type {TimeInForce}
     * @memberof ManualTrade
     */
    'time_in_force'?: TimeInForce;
    /**
     * 
     * @type {ManualTradeSymbol}
     * @memberof ManualTrade
     */
    'symbol'?: ManualTradeSymbol;
    /**
     * 
     * @type {Action}
     * @memberof ManualTrade
     */
    'action'?: Action;
    /**
     * Trade Units
     * @type {number}
     * @memberof ManualTrade
     */
    'units'?: number;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof ManualTrade
     */
    'price'?: number;
}
/**
 * Manual Trade and Impact object
 * @export
 * @interface ManualTradeAndImpact
 */
export interface ManualTradeAndImpact {
    [key: string]: any;

    /**
     * 
     * @type {ManualTrade}
     * @memberof ManualTradeAndImpact
     */
    'trade'?: ManualTrade;
    /**
     * 
     * @type {Array<ManualTrade>}
     * @memberof ManualTradeAndImpact
     */
    'trade_impacts'?: Array<ManualTrade>;
    /**
     * 
     * @type {ManualTradeBalance}
     * @memberof ManualTradeAndImpact
     */
    'combined_remaining_balance'?: ManualTradeBalance;
}
/**
 * Balance
 * @export
 * @interface ManualTradeBalance
 */
export interface ManualTradeBalance {
    [key: string]: any;

    /**
     * 
     * @type {Account}
     * @memberof ManualTradeBalance
     */
    'account'?: Account;
    /**
     * 
     * @type {Currency}
     * @memberof ManualTradeBalance
     */
    'currency'?: Currency;
    /**
     * Cash
     * @type {number}
     * @memberof ManualTradeBalance
     */
    'cash'?: number;
}
/**
 * Manual Trade Form
 * @export
 * @interface ManualTradeForm
 */
export interface ManualTradeForm {
    /**
     * 
     * @type {string}
     * @memberof ManualTradeForm
     */
    'account_id'?: string;
    /**
     * 
     * @type {Action}
     * @memberof ManualTradeForm
     */
    'action'?: Action;
    /**
     * 
     * @type {OrderType}
     * @memberof ManualTradeForm
     */
    'order_type'?: OrderType;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof ManualTradeForm
     */
    'price'?: number;
    /**
     * Stop Price. If stop loss or stop limit order, the price to trigger the stop
     * @type {number}
     * @memberof ManualTradeForm
     */
    'stop'?: number;
    /**
     * 
     * @type {TimeInForce}
     * @memberof ManualTradeForm
     */
    'time_in_force'?: TimeInForce;
    /**
     * Trade Units
     * @type {number}
     * @memberof ManualTradeForm
     */
    'units'?: number;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeForm
     */
    'universal_symbol_id'?: string;
}
/**
 * Manual trade symbol object
 * @export
 * @interface ManualTradeSymbol
 */
export interface ManualTradeSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'brokerage_symbol_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'universal_symbol_id'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof ManualTradeSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ManualTradeSymbol
     */
    'symbol'?: string;
}
/**
 * Example for failed request response
 * @export
 * @interface Model400FailedRequestResponse
 */
export interface Model400FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model400FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model400FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model401FailedRequestResponse
 */
export interface Model401FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model401FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model401FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model403FailedRequestResponse
 */
export interface Model403FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model403FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model403FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * Example for failed request response
 * @export
 * @interface Model404FailedRequestResponse
 */
export interface Model404FailedRequestResponse {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof Model404FailedRequestResponse
     */
    'default_detail'?: any;
    /**
     * 
     * @type {any}
     * @memberof Model404FailedRequestResponse
     */
    'default_code'?: any;
}
/**
 * 
 * @export
 * @interface ModelAssetClass
 */
export interface ModelAssetClass {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ModelAssetClass
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAssetClass
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ModelAssetClassDetails
 */
export interface ModelAssetClassDetails {
    /**
     * 
     * @type {ModelAssetClass}
     * @memberof ModelAssetClassDetails
     */
    'model_asset_class'?: ModelAssetClass;
    /**
     * 
     * @type {Array<ModelAssetClassTarget>}
     * @memberof ModelAssetClassDetails
     */
    'model_asset_class_target'?: Array<ModelAssetClassTarget>;
}
/**
 * 
 * @export
 * @interface ModelAssetClassTarget
 */
export interface ModelAssetClassTarget {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ModelAssetClassTarget
     */
    'symbol'?: UniversalSymbol;
}
/**
 * 
 * @export
 * @interface ModelPortfolio
 */
export interface ModelPortfolio {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ModelPortfolio
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPortfolio
     */
    'name'?: string;
    /**
     * Enum definitions -> [-1: Unassigned, 0: Security Model Portfolio, 1: Asset Class Portfolio]
     * @type {number}
     * @memberof ModelPortfolio
     */
    'model_type'?: ModelPortfolioModelTypeEnum;
}

export const ModelPortfolioModelTypeEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ModelPortfolioModelTypeEnum = typeof ModelPortfolioModelTypeEnum[keyof typeof ModelPortfolioModelTypeEnum];

/**
 * 
 * @export
 * @interface ModelPortfolioAssetClass
 */
export interface ModelPortfolioAssetClass {
    [key: string]: any;

    /**
     * 
     * @type {ModelAssetClass}
     * @memberof ModelPortfolioAssetClass
     */
    'model_asset_class'?: ModelAssetClass;
    /**
     * 
     * @type {number}
     * @memberof ModelPortfolioAssetClass
     */
    'percent'?: number;
}
/**
 * 
 * @export
 * @interface ModelPortfolioDetails
 */
export interface ModelPortfolioDetails {
    /**
     * 
     * @type {ModelPortfolio}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio'?: ModelPortfolio;
    /**
     * 
     * @type {Array<ModelPortfolioSecurity>}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio_security'?: Array<ModelPortfolioSecurity>;
    /**
     * 
     * @type {Array<ModelPortfolioAssetClass>}
     * @memberof ModelPortfolioDetails
     */
    'model_portfolio_asset_class'?: Array<ModelPortfolioAssetClass>;
}
/**
 * 
 * @export
 * @interface ModelPortfolioSecurity
 */
export interface ModelPortfolioSecurity {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof ModelPortfolioSecurity
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof ModelPortfolioSecurity
     */
    'percent'?: number;
}
/**
 * 
 * @export
 * @interface MonthlyDividends
 */
export interface MonthlyDividends {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof MonthlyDividends
     */
    'date'?: string;
    /**
     * 
     * @type {Array<DividendAtDate>}
     * @memberof MonthlyDividends
     */
    'dividends'?: Array<DividendAtDate>;
}
/**
 * 
 * @export
 * @interface NetContributions
 */
export interface NetContributions {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof NetContributions
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetContributions
     */
    'contributions'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetContributions
     */
    'currency'?: string;
}
/**
 * Object representing total dividends received during a timeframe
 * @export
 * @interface NetDividend
 */
export interface NetDividend {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof NetDividend
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof NetDividend
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetDividend
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface OptionChainInner
 */
export interface OptionChainInner {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'listingExchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionChainInner
     */
    'optionExerciseType'?: string;
    /**
     * 
     * @type {Array<OptionChainInnerChainPerRootInner>}
     * @memberof OptionChainInner
     */
    'chainPerRoot'?: Array<OptionChainInnerChainPerRootInner>;
}
/**
 * 
 * @export
 * @interface OptionChainInnerChainPerRootInner
 */
export interface OptionChainInnerChainPerRootInner {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'optionRoot'?: string;
    /**
     * 
     * @type {Array<OptionChainInnerChainPerRootInnerChainPerStrikePriceInner>}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'chainPerStrikePrice'?: Array<OptionChainInnerChainPerRootInnerChainPerStrikePriceInner>;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInner
     */
    'multiplier'?: number;
}
/**
 * 
 * @export
 * @interface OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
 */
export interface OptionChainInnerChainPerRootInnerChainPerStrikePriceInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'strikePrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'callSymbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptionChainInnerChainPerRootInnerChainPerStrikePriceInner
     */
    'putSymbolId'?: number;
}
/**
 * Option Holdings
 * @export
 * @interface OptionsHoldings
 */
export interface OptionsHoldings {
    [key: string]: any;

    /**
     * Options information
     * @type {string}
     * @memberof OptionsHoldings
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionsHoldings
     */
    'symbol'?: string;
    /**
     * 
     * @type {OptionsSymbol}
     * @memberof OptionsHoldings
     */
    'option_symbol'?: OptionsSymbol;
    /**
     * Trade Price if limit or stop limit order
     * @type {number}
     * @memberof OptionsHoldings
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof OptionsHoldings
     */
    'currency'?: string;
}
/**
 * Options Symbol
 * @export
 * @interface OptionsSymbol
 */
export interface OptionsSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'ticker'?: string;
    /**
     * 
     * @type {number}
     * @memberof OptionsSymbol
     */
    'strike_price'?: number;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'expiration_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_mini_option'?: boolean;
    /**
     * 
     * @type {UnderlyingSymbol}
     * @memberof OptionsSymbol
     */
    'underlying_symbol'?: UnderlyingSymbol;
    /**
     * 
     * @type {string}
     * @memberof OptionsSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {any}
     * @memberof OptionsSymbol
     */
    'security_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof OptionsSymbol
     */
    'listing_exchange'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_quotable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OptionsSymbol
     */
    'is_tradable'?: boolean;
}
/**
 * Order Type
 * @export
 * @enum {string}
 */

export const OrderType = {
    Limit: 'Limit',
    Market: 'Market',
    StopLimit: 'StopLimit',
    StopLoss: 'StopLoss'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * SnapTrade Partner metadata
 * @export
 * @interface PartnerData
 */
export interface PartnerData {
    [key: string]: any;

    /**
     * URI to redirect user back to after user is done adding brokerage connections
     * @type {string}
     * @memberof PartnerData
     */
    'redirect_uri'?: string;
    /**
     * Brokerages that can be accessed by partners
     * @type {Array<Brokerage>}
     * @memberof PartnerData
     */
    'allowed_brokerages'?: Array<Brokerage>;
    /**
     * Name of Snaptrade Partner
     * @type {string}
     * @memberof PartnerData
     */
    'name'?: string;
    /**
     * Slug of Snaptrade Partner
     * @type {string}
     * @memberof PartnerData
     */
    'slug'?: string;
    /**
     * URL to partner\'s logo
     * @type {string}
     * @memberof PartnerData
     */
    'logo_url'?: string;
    /**
     * Shows if pin is required by users to access connection page
     * @type {boolean}
     * @memberof PartnerData
     */
    'pin_required'?: boolean;
    /**
     * Shows if users of Snaptrade partners can access trade endpoints
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_trades'?: boolean;
    /**
     * Shows if Snaptrade partners can get user holdings data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_holdings'?: boolean;
    /**
     * Shows if Snaptrade partners can get users account history data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_account_history'?: boolean;
    /**
     * Shows if Snaptrade partners can get users holdings data
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_reference_data'?: boolean;
    /**
     * Shows if users Snaptrade partners can access portfolio group management features
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_portfolio_management'?: boolean;
    /**
     * Shows if Snaptrade partners can get users account order history
     * @type {boolean}
     * @memberof PartnerData
     */
    'can_access_orders'?: boolean;
}
/**
 * 
 * @export
 * @interface PastValue
 */
export interface PastValue {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof PastValue
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof PastValue
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof PastValue
     */
    'currency'?: string;
}
/**
 * Performance Custom Response Object
 * @export
 * @interface PerformanceCustom
 */
export interface PerformanceCustom {
    [key: string]: any;

    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'totalEquityTimeframe'?: Array<PastValue>;
    /**
     * 
     * @type {NetContributions}
     * @memberof PerformanceCustom
     */
    'contributions'?: NetContributions;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'contributionTimeframe'?: Array<PastValue>;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'contributionTimeframeCumulative'?: Array<PastValue>;
    /**
     * 
     * @type {Array<PastValue>}
     * @memberof PerformanceCustom
     */
    'withdrawalTimeframe'?: Array<PastValue>;
    /**
     * Current streak of cosecutive months where contributions were made
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionStreak'?: number;
    /**
     * Number of months in the timeframe with contributions
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionMonthsContributed'?: number;
    /**
     * Total months in timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'contributionTotalMonths'?: number;
    /**
     * 
     * @type {Array<NetDividend>}
     * @memberof PerformanceCustom
     */
    'dividends'?: Array<NetDividend>;
    /**
     * Total dividends received over the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'dividendIncome'?: number;
    /**
     * Average dividends received per month over the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'monthlyDividends'?: number;
    /**
     * list of tickers which may not be supported or may not have accurate price data
     * @type {Array<string>}
     * @memberof PerformanceCustom
     */
    'badTickers'?: Array<string>;
    /**
     * 
     * @type {Array<MonthlyDividends>}
     * @memberof PerformanceCustom
     */
    'dividendTimeline'?: Array<MonthlyDividends>;
    /**
     * commissions incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'commissions'?: number;
    /**
     * forex fees incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'forexFees'?: number;
    /**
     * other fees incurred during the timeframe
     * @type {number}
     * @memberof PerformanceCustom
     */
    'fees'?: number;
    /**
     * The return rate over the timeframe. Annualized if timeframe is longer than 1 year
     * @type {number}
     * @memberof PerformanceCustom
     */
    'rateOfReturn'?: number;
    /**
     * 
     * @type {Array<SubPeriodReturnRate>}
     * @memberof PerformanceCustom
     */
    'returnRateTimeframe'?: Array<SubPeriodReturnRate>;
    /**
     * Whether the user has detailed mode enabled (more frequent data points for totalEquity and contribution timeframes)
     * @type {boolean}
     * @memberof PerformanceCustom
     */
    'detailedMode'?: boolean;
}
/**
 * 
 * @export
 * @interface PortfolioGroup
 */
export interface PortfolioGroup {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof PortfolioGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortfolioGroup
     */
    'name'?: string;
}
/**
 * Summary of all relevant information about a portfolio group.
 * @export
 * @interface PortfolioGroupInfo
 */
export interface PortfolioGroupInfo {
    [key: string]: any;

    /**
     * 
     * @type {Array<UniversalSymbol>}
     * @memberof PortfolioGroupInfo
     */
    'symbols'?: Array<UniversalSymbol>;
    /**
     * 
     * @type {Array<UniversalSymbol>}
     * @memberof PortfolioGroupInfo
     */
    'quotable_symbols'?: Array<UniversalSymbol>;
    /**
     * 
     * @type {Array<Balance>}
     * @memberof PortfolioGroupInfo
     */
    'balances'?: Array<Balance>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof PortfolioGroupInfo
     */
    'positions'?: Array<Position>;
    /**
     * 
     * @type {Array<TargetAsset>}
     * @memberof PortfolioGroupInfo
     */
    'target_positions'?: Array<TargetAsset>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof PortfolioGroupInfo
     */
    'ideal_positions'?: Array<Position>;
    /**
     * 
     * @type {Array<ExcludedAsset>}
     * @memberof PortfolioGroupInfo
     */
    'excluded_positions'?: Array<ExcludedAsset>;
    /**
     * 
     * @type {Array<CalculatedTrade>}
     * @memberof PortfolioGroupInfo
     */
    'calculated_trades'?: Array<CalculatedTrade>;
    /**
     * 
     * @type {Array<BrokerageAuthorization>}
     * @memberof PortfolioGroupInfo
     */
    'brokerage_authorizations'?: Array<BrokerageAuthorization>;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupInfo
     */
    'accuracy'?: number;
    /**
     * 
     * @type {PortfolioGroupSettings}
     * @memberof PortfolioGroupInfo
     */
    'settings'?: PortfolioGroupSettings;
}
/**
 * Details of a security held
 * @export
 * @interface PortfolioGroupPosition
 */
export interface PortfolioGroupPosition {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof PortfolioGroupPosition
     */
    'symbol'?: UniversalSymbol;
    /**
     * Last known market price for the symbol
     * @type {number}
     * @memberof PortfolioGroupPosition
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupPosition
     */
    'units'?: number;
}
/**
 * 
 * @export
 * @interface PortfolioGroupSettings
 */
export interface PortfolioGroupSettings {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof PortfolioGroupSettings
     */
    'buyOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortfolioGroupSettings
     */
    'cash_optimizer'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortfolioGroupSettings
     */
    'notifyFrequency'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortfolioGroupSettings
     */
    'driftThreshold'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof PortfolioGroupSettings
     */
    'preferred_currency'?: Currency;
}
/**
 * Account Position
 * @export
 * @interface Position
 */
export interface Position {
    [key: string]: any;

    /**
     * 
     * @type {PositionSymbol}
     * @memberof Position
     */
    'symbol'?: PositionSymbol;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'units'?: number;
    /**
     * Last known market price for the symbol
     * @type {number}
     * @memberof Position
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'open_pnl'?: number;
    /**
     * Deprecated, use the units field for both fractional and integer units going forward
     * @type {number}
     * @memberof Position
     */
    'fractional_units'?: number | null;
    /**
     * Average purchase price for this position. Either returned by the underlying broker or calculated using historical transactions.
     * @type {number}
     * @memberof Position
     */
    'average_purchase_price'?: number;
}
/**
 * Symbol returned in position object
 * @export
 * @interface PositionSymbol
 */
export interface PositionSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof PositionSymbol
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {string}
     * @memberof PositionSymbol
     */
    'local_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSymbol
     */
    'is_quotable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionSymbol
     */
    'is_tradable'?: boolean;
}
/**
 * Response when register user is successful
 * @export
 * @interface RedirectTokenandPin
 */
export interface RedirectTokenandPin {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof RedirectTokenandPin
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectTokenandPin
     */
    'pin'?: string;
}
/**
 * Security Type
 * @export
 * @interface SecurityType
 */
export interface SecurityType {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityType
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SecurityType
     */
    'is_supported'?: boolean;
}
/**
 * Status of user acceptance of SnapTrade API disclaimer
 * @export
 * @interface SnapTradeAPIDisclaimerAcceptStatus
 */
export interface SnapTradeAPIDisclaimerAcceptStatus {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof SnapTradeAPIDisclaimerAcceptStatus
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeAPIDisclaimerAcceptStatus
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface SnapTradeAcceptDisclaimerPostRequest
 */
export interface SnapTradeAcceptDisclaimerPostRequest {
    /**
     * A boolean that indicates whether this user has accepted the disclaimer or not.
     * @type {boolean}
     * @memberof SnapTradeAcceptDisclaimerPostRequest
     */
    'accepted'?: boolean;
}
/**
 * SnapTradeUser Investment Account
 * @export
 * @interface SnapTradeHoldingsAccount
 */
export interface SnapTradeHoldingsAccount {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'id'?: string;
    /**
     * 
     * @type {BrokerageAuthorization}
     * @memberof SnapTradeHoldingsAccount
     */
    'brokerage_authorization'?: BrokerageAuthorization;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'portfolio_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsAccount
     */
    'institution_name'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof SnapTradeHoldingsAccount
     */
    'meta'?: { [key: string]: any; };
}
/**
 * Total Value of the account
 * @export
 * @interface SnapTradeHoldingsTotalValue
 */
export interface SnapTradeHoldingsTotalValue {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof SnapTradeHoldingsTotalValue
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeHoldingsTotalValue
     */
    'currency'?: string;
}
/**
 * @type SnapTradeLoginPost200Response
 * @export
 */
export type SnapTradeLoginPost200Response = EncryptedResponse | LoginRedirectURI;

/**
 * Data to login a user via SnapTrade Partner
 * @export
 * @interface SnapTradeLoginUserRequestBody
 */
export interface SnapTradeLoginUserRequestBody {
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'broker'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'immediateRedirect'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'customRedirect'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'reconnect'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapTradeLoginUserRequestBody
     */
    'connectionType'?: SnapTradeLoginUserRequestBodyConnectionTypeEnum;
}

export const SnapTradeLoginUserRequestBodyConnectionTypeEnum = {
    Read: 'read',
    Trade: 'trade'
} as const;

export type SnapTradeLoginUserRequestBodyConnectionTypeEnum = typeof SnapTradeLoginUserRequestBodyConnectionTypeEnum[keyof typeof SnapTradeLoginUserRequestBodyConnectionTypeEnum];

/**
 * Data required to register a user via SnapTrade Partner
 * @export
 * @interface SnapTradeRegisterUserRequestBody
 */
export interface SnapTradeRegisterUserRequestBody {
    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof SnapTradeRegisterUserRequestBody
     */
    'userId'?: string;
    /**
     * Open SSH RSA public key
     * @type {string}
     * @memberof SnapTradeRegisterUserRequestBody
     */
    'rsaPublicKey'?: string;
}
/**
 * Status of API
 * @export
 * @interface Status
 */
export interface Status {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'version'?: number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'timestamp'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'online'?: boolean;
}
/**
 * The strategy impact
 * @export
 * @interface StrategyImpact
 */
export interface StrategyImpact {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'estimatedCommissions'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'buyingPowerEffect'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'buyingPowerResult'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'maintExcessEffect'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'maintExcessResult'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'tradeValueCalculation'?: string;
    /**
     * 
     * @type {Array<StrategyImpactLegsInner>}
     * @memberof StrategyImpact
     */
    'legs'?: Array<StrategyImpactLegsInner>;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'effect'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpact
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpact
     */
    'strategy'?: string;
}
/**
 * 
 * @export
 * @interface StrategyImpactLegsInner
 */
export interface StrategyImpactLegsInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'legId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyImpactLegsInner
     */
    'legRatioQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'avgExecPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyImpactLegsInner
     */
    'lastExecPrice'?: string;
}
/**
 * The reponse for a correctly placed order
 * @export
 * @interface StrategyOrderPlace
 */
export interface StrategyOrderPlace {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlace
     */
    'orderId'?: number;
    /**
     * 
     * @type {Array<StrategyOrderPlaceOrdersInner>}
     * @memberof StrategyOrderPlace
     */
    'orders'?: Array<StrategyOrderPlaceOrdersInner>;
}
/**
 * 
 * @export
 * @interface StrategyOrderPlaceOrdersInner
 */
export interface StrategyOrderPlaceOrdersInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'totalQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'openQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'filledQuantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'canceledQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderType'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'limitPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'stopPrice'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isAllOrNone'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isAnonymous'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'icebergQuantity'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'minQuantity'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'avgExecPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'lastExecPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'timeInForce'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'gtdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'rejectionReason'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'chainId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'updateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'notes'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'primaryRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'secondaryRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderRoute'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'venueHoldingOrder'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'comissionCharged'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'exchangeOrderId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isSignificantShareHolder'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isInsider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isLimitOffsetInDollar'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'placementCommission'?: string;
    /**
     * 
     * @type {Array<StrategyOrderPlaceOrdersInnerLegsInner>}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'legs'?: Array<StrategyOrderPlaceOrdersInnerLegsInner>;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'strategyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'triggerStopPrice'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderGroupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'orderClass'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyOrderPlaceOrdersInner
     */
    'isCrossZero'?: boolean;
}
/**
 * 
 * @export
 * @interface StrategyOrderPlaceOrdersInnerLegsInner
 */
export interface StrategyOrderPlaceOrdersInnerLegsInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'legId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'symbol'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'symbolId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'legRatioQuantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'side'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'avgExecPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyOrderPlaceOrdersInnerLegsInner
     */
    'lastExecPrice'?: string;
}
/**
 * 
 * @export
 * @interface StrategyQuotesInner
 */
export interface StrategyQuotesInner {
    [key: string]: any;

    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'variantId'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'bidPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'askPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyQuotesInner
     */
    'underlying'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'underlyingId'?: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyQuotesInner
     */
    'openPrice'?: string;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'volatility'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'delta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'gamma'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'theta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'vega'?: number;
    /**
     * 
     * @type {number}
     * @memberof StrategyQuotesInner
     */
    'rho'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StrategyQuotesInner
     */
    'isRealTime'?: boolean;
}
/**
 * 
 * @export
 * @interface SubPeriodReturnRate
 */
export interface SubPeriodReturnRate {
    [key: string]: any;

    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof SubPeriodReturnRate
     */
    'periodStart'?: string;
    /**
     * Date used to specify timeframe for a reporting call (in YYYY-MM-DD format)
     * @type {string}
     * @memberof SubPeriodReturnRate
     */
    'periodEnd'?: string;
    /**
     * The return rate for the given period
     * @type {number}
     * @memberof SubPeriodReturnRate
     */
    'rateOfReturn'?: number;
}
/**
 * Symbol
 * @export
 * @interface Symbol
 */
export interface Symbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'raw_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof Symbol
     */
    'name'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Symbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Exchange}
     * @memberof Symbol
     */
    'exchange'?: Exchange;
}
/**
 * Symbol query for searching for symbols
 * @export
 * @interface SymbolQuery
 */
export interface SymbolQuery {
    /**
     * 
     * @type {string}
     * @memberof SymbolQuery
     */
    'substring'?: string;
}
/**
 * Symbols and Tickers Quotes object
 * @export
 * @interface SymbolsQuotes
 */
export interface SymbolsQuotes {
    [key: string]: any;

    /**
     * 
     * @type {UniversalSymbol}
     * @memberof SymbolsQuotes
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'bid_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'ask_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'last_trade_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'bid_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof SymbolsQuotes
     */
    'ask_size'?: number;
}
/**
 * Target percentage of a certain asset
 * @export
 * @interface TargetAsset
 */
export interface TargetAsset {
    /**
     * 
     * @type {string}
     * @memberof TargetAsset
     */
    'id'?: string;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof TargetAsset
     */
    'symbol'?: UniversalSymbol;
    /**
     * 
     * @type {number}
     * @memberof TargetAsset
     */
    'percent'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TargetAsset
     */
    'is_supported'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TargetAsset
     */
    'is_excluded'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof TargetAsset
     */
    'meta'?: object;
}
/**
 * Trade time in force:   * FOK - Fill Or Kill   * Day - Day   * GTC - Good Til Canceled 
 * @export
 * @enum {string}
 */

export const TimeInForce = {
    Day: 'Day',
    Fok: 'FOK',
    Gtc: 'GTC'
} as const;

export type TimeInForce = typeof TimeInForce[keyof typeof TimeInForce];


/**
 * A trade object
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    'id'?: string;
    /**
     * 
     * @type {Account}
     * @memberof Trade
     */
    'account'?: Account;
    /**
     * 
     * @type {BrokerageSymbol}
     * @memberof Trade
     */
    'symbol'?: BrokerageSymbol;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof Trade
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    'action'?: TradeActionEnum;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'units'?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    'sequence'?: number;
}

export const TradeActionEnum = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type TradeActionEnum = typeof TradeActionEnum[keyof typeof TradeActionEnum];

/**
 * Execution status of a trade
 * @export
 * @interface TradeExecutionStatus
 */
export interface TradeExecutionStatus {
    [key: string]: any;

    /**
     * 
     * @type {BrokerageSymbol}
     * @memberof TradeExecutionStatus
     */
    'symbol'?: BrokerageSymbol;
    /**
     * 
     * @type {UniversalSymbol}
     * @memberof TradeExecutionStatus
     */
    'universal_symbol'?: UniversalSymbol;
    /**
     * 
     * @type {Trade}
     * @memberof TradeExecutionStatus
     */
    'trade'?: Trade;
    /**
     * Execution state of a trade
     * @type {string}
     * @memberof TradeExecutionStatus
     */
    'state'?: TradeExecutionStatusStateEnum;
    /**
     * Number of filled units
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'filled_units'?: number;
    /**
     * Action of executed trade
     * @type {string}
     * @memberof TradeExecutionStatus
     */
    'action'?: TradeExecutionStatusActionEnum;
    /**
     * Price of execution
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'price'?: number;
    /**
     * Fees paid from executing trade
     * @type {number}
     * @memberof TradeExecutionStatus
     */
    'commissions'?: number;
    /**
     * Other misc. data
     * @type {{ [key: string]: any; }}
     * @memberof TradeExecutionStatus
     */
    'meta'?: { [key: string]: any; };
}

export const TradeExecutionStatusStateEnum = {
    Executed: 'Executed',
    Canceled: 'Canceled',
    Rejected: 'Rejected',
    Failed: 'Failed',
    NotExecuted: 'Not Executed'
} as const;

export type TradeExecutionStatusStateEnum = typeof TradeExecutionStatusStateEnum[keyof typeof TradeExecutionStatusStateEnum];
export const TradeExecutionStatusActionEnum = {
    Buy: 'BUY',
    Sell: 'SELL'
} as const;

export type TradeExecutionStatusActionEnum = typeof TradeExecutionStatusActionEnum[keyof typeof TradeExecutionStatusActionEnum];

/**
 * Impact of a group of trade
 * @export
 * @interface TradeImpact
 */
export interface TradeImpact {
    [key: string]: any;

    /**
     * 
     * @type {Account}
     * @memberof TradeImpact
     */
    'account'?: Account;
    /**
     * 
     * @type {Currency}
     * @memberof TradeImpact
     */
    'currency'?: Currency;
    /**
     * Remaining balance after executing all trades
     * @type {number}
     * @memberof TradeImpact
     */
    'remaining_cash'?: number;
    /**
     * Total estimated commissions across all trades to make
     * @type {number}
     * @memberof TradeImpact
     */
    'estimated_commissions'?: number;
    /**
     * Estimated forex fees to pay to excute trades
     * @type {number}
     * @memberof TradeImpact
     */
    'forex_fees'?: number;
}
/**
 * 
 * @export
 * @interface TradeOcoPostRequest
 */
export interface TradeOcoPostRequest {
    /**
     * The ID of first trade object obtained from trade/impact endpoint
     * @type {any}
     * @memberof TradeOcoPostRequest
     */
    'first_trade_id'?: any;
    /**
     * The ID of second trade object obtained from trade/impact endpoint
     * @type {any}
     * @memberof TradeOcoPostRequest
     */
    'second_trade_id'?: any;
}
/**
 * US Stock Exchange
 * @export
 * @interface USExchange
 */
export interface USExchange {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'mic_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'close_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof USExchange
     */
    'suffix'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof USExchange
     */
    'allows_cryptocurrency_symbols'?: boolean;
}
/**
 * Underlying Symbol
 * @export
 * @interface UnderlyingSymbol
 */
export interface UnderlyingSymbol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UnderlyingSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof UnderlyingSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {USExchange}
     * @memberof UnderlyingSymbol
     */
    'exchange'?: USExchange;
    /**
     * 
     * @type {SecurityType}
     * @memberof UnderlyingSymbol
     */
    'type'?: SecurityType;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof UnderlyingSymbol
     */
    'currencies'?: Array<Currency>;
}
/**
 * A transaction or activity from an institution
 * @export
 * @interface UniversalActivity
 */
export interface UniversalActivity {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'id'?: string;
    /**
     * 
     * @type {AccountSimple}
     * @memberof UniversalActivity
     */
    'account'?: AccountSimple;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'amount'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof UniversalActivity
     */
    'currency'?: Currency;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'fee'?: number;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'institution'?: string;
    /**
     * If an option transaction, then it\'s type (BUY_TO_OPEN, SELL_TO_CLOSE, etc), otherwise empty string
     * @type {string}
     * @memberof UniversalActivity
     */
    'option_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof UniversalActivity
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'settlement_date'?: string;
    /**
     * 
     * @type {Symbol}
     * @memberof UniversalActivity
     */
    'symbol'?: Symbol;
    /**
     * 
     * @type {OptionsSymbol}
     * @memberof UniversalActivity
     */
    'option_symbol'?: OptionsSymbol;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'trade_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalActivity
     */
    'type'?: UniversalActivityTypeEnum;
    /**
     * Usually but not necessarily an integer
     * @type {number}
     * @memberof UniversalActivity
     */
    'units'?: number;
}

export const UniversalActivityTypeEnum = {
    Dividend: 'DIVIDEND',
    Buy: 'BUY',
    Sell: 'SELL',
    Contribution: 'CONTRIBUTION',
    Withdrawal: 'WITHDRAWAL',
    ExternalAssetTransferIn: 'EXTERNAL_ASSET_TRANSFER_IN',
    ExternalAssetTransferOut: 'EXTERNAL_ASSET_TRANSFER_OUT',
    InternalCashTransferIn: 'INTERNAL_CASH_TRANSFER_IN',
    InternalCashTransferOut: 'INTERNAL_CASH_TRANSFER_OUT',
    InternalAssetTransferIn: 'INTERNAL_ASSET_TRANSFER_IN',
    InternalAssetTransferOut: 'INTERNAL_ASSET_TRANSFER_OUT',
    Interest: 'INTEREST',
    Rebate: 'REBATE',
    GovGrant: 'GOV_GRANT',
    Tax: 'TAX',
    Fee: 'FEE',
    Rei: 'REI',
    Fxt: 'FXT'
} as const;

export type UniversalActivityTypeEnum = typeof UniversalActivityTypeEnum[keyof typeof UniversalActivityTypeEnum];

/**
 * Universal symbol
 * @export
 * @interface UniversalSymbol
 */
export interface UniversalSymbol {
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'raw_symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSymbol
     */
    'description'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof UniversalSymbol
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Exchange}
     * @memberof UniversalSymbol
     */
    'exchange'?: Exchange;
    /**
     * 
     * @type {SecurityType}
     * @memberof UniversalSymbol
     */
    'type'?: SecurityType;
    /**
     * 
     * @type {Array<Currency>}
     * @memberof UniversalSymbol
     */
    'currencies'?: Array<Currency>;
}
/**
 * An API error log for a specific SnapTrade user.
 * @export
 * @interface UserErrorLog
 */
export interface UserErrorLog {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'requestedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'response'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserErrorLog
     */
    'statusCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'queryParams'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'httpMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserErrorLog
     */
    'endpoint'?: string;
}
/**
 * Response when register user is successful
 * @export
 * @interface UserIDandSecret
 */
export interface UserIDandSecret {
    [key: string]: any;

    /**
     * SnapTrade User ID. Provided by SnapTrade Partner. Can be any string, as long as it\'s unique to a user
     * @type {string}
     * @memberof UserIDandSecret
     */
    'userId'?: string;
    /**
     * SnapTrade User Secret randomly generated by Passiv.
     * @type {string}
     * @memberof UserIDandSecret
     */
    'userSecret'?: string;
}
/**
 * Passiv user account settings
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'receive_cash_notification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'receive_drift_notification'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'user_trial_activated'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'activated_trial_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'demo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'api_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserSettings
     */
    'drift_threshold'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof UserSettings
     */
    'preferred_currency'?: Currency;
}

/**
 * APIDisclaimerApi - axios parameter creator
 * @export
 */
export const APIDisclaimerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeAcceptDisclaimerPostRequest} snapTradeAcceptDisclaimerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeAcceptDisclaimerPost: async (userId: string, userSecret: string, snapTradeAcceptDisclaimerPostRequest: SnapTradeAcceptDisclaimerPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('snapTradeAcceptDisclaimerPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('snapTradeAcceptDisclaimerPost', 'userSecret', userSecret)
            // verify required parameter 'snapTradeAcceptDisclaimerPostRequest' is not null or undefined
            assertParamExists('snapTradeAcceptDisclaimerPost', 'snapTradeAcceptDisclaimerPostRequest', snapTradeAcceptDisclaimerPostRequest)
            const localVarPath = `/snapTrade/acceptDisclaimer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapTradeAcceptDisclaimerPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIDisclaimerApi - functional programming interface
 * @export
 */
export const APIDisclaimerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIDisclaimerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeAcceptDisclaimerPostRequest} snapTradeAcceptDisclaimerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeAcceptDisclaimerPost(userId: string, userSecret: string, snapTradeAcceptDisclaimerPostRequest: SnapTradeAcceptDisclaimerPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapTradeAPIDisclaimerAcceptStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeAcceptDisclaimerPost(userId, userSecret, snapTradeAcceptDisclaimerPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIDisclaimerApi - factory interface
 * @export
 */
export const APIDisclaimerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIDisclaimerApiFp(configuration)
    return {
        /**
         * 
         * @summary Accept or Reject SnapTrade disclaimer agreement
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeAcceptDisclaimerPostRequest} snapTradeAcceptDisclaimerPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeAcceptDisclaimerPost(userId: string, userSecret: string, snapTradeAcceptDisclaimerPostRequest: SnapTradeAcceptDisclaimerPostRequest, options?: any): AxiosPromise<SnapTradeAPIDisclaimerAcceptStatus> {
            return localVarFp.snapTradeAcceptDisclaimerPost(userId, userSecret, snapTradeAcceptDisclaimerPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIDisclaimerApi - object-oriented interface
 * @export
 * @class APIDisclaimerApi
 * @extends {BaseAPI}
 */
export class APIDisclaimerApi extends BaseAPI {
    /**
     * 
     * @summary Accept or Reject SnapTrade disclaimer agreement
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {SnapTradeAcceptDisclaimerPostRequest} snapTradeAcceptDisclaimerPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIDisclaimerApi
     */
    public snapTradeAcceptDisclaimerPost(userId: string, userSecret: string, snapTradeAcceptDisclaimerPostRequest: SnapTradeAcceptDisclaimerPostRequest, options?: AxiosRequestConfig) {
        return APIDisclaimerApiFp(this.configuration).snapTradeAcceptDisclaimerPost(userId, userSecret, snapTradeAcceptDisclaimerPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * APIStatusApi - axios parameter creator
 * @export
 */
export const APIStatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIStatusApi - functional programming interface
 * @export
 */
export const APIStatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIStatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIStatusApi - factory interface
 * @export
 */
export const APIStatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIStatusApiFp(configuration)
    return {
        /**
         * Check whether the API is operational and verify timestamps.
         * @summary Get API Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: any): AxiosPromise<Status> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIStatusApi - object-oriented interface
 * @export
 * @class APIStatusApi
 * @extends {BaseAPI}
 */
export class APIStatusApi extends BaseAPI {
    /**
     * Check whether the API is operational and verify timestamps.
     * @summary Get API Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIStatusApi
     */
    public rootGet(options?: AxiosRequestConfig) {
        return APIStatusApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AccountInformationApi - axios parameter creator
 * @export
 */
export const AccountInformationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdBalancesGet: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdBalancesGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdBalancesGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdBalancesGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/balances`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdGet: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdHoldingsGet: async (accountId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdHoldingsGet', 'accountId', accountId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdHoldingsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdHoldingsGet', 'userSecret', userSecret)
            const localVarPath = `/accounts/{accountId}/holdings`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdPositionsGet: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdPositionsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdPositionsGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdPositionsGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/positions`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdPut: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdPut', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdPut', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdPut', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsGet', 'userSecret', userSecret)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsGet: async (userId: string, userSecret: string, brokerageAuthorizations?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('holdingsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('holdingsGet', 'userSecret', userSecret)
            const localVarPath = `/holdings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (brokerageAuthorizations !== undefined) {
                localVarQueryParameter['brokerage_authorizations'] = brokerageAuthorizations;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountInformationApi - functional programming interface
 * @export
 */
export const AccountInformationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountInformationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdBalancesGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdBalancesGet(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdGet(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdHoldingsGet(accountId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHoldings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdHoldingsGet(accountId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdPositionsGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Position>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdPositionsGet(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdPut(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdPut(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsGet(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsGet(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async holdingsGet(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountHoldings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.holdingsGet(userId, userSecret, brokerageAuthorizations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountInformationApi - factory interface
 * @export
 */
export const AccountInformationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountInformationApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all cash balances of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdBalancesGet(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.accountsAccountIdBalancesGet(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return details of a specific investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to get detail of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdGet(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.accountsAccountIdGet(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List balances, positions and orders for the specified account.
         * @param {string} accountId The ID of the account to fetch holdings for.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdHoldingsGet(accountId: string, userId: string, userSecret: string, options?: any): AxiosPromise<AccountHoldings> {
            return localVarFp.accountsAccountIdHoldingsGet(accountId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all positions of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdPositionsGet(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Position>> {
            return localVarFp.accountsAccountIdPositionsGet(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update details of an investment account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdPut(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.accountsAccountIdPut(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all investment accounts for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(userId: string, userSecret: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.accountsGet(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all accounts for the user, plus balances and positions for each account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        holdingsGet(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: any): AxiosPromise<Array<AccountHoldings>> {
            return localVarFp.holdingsGet(userId, userSecret, brokerageAuthorizations, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountInformationApi - object-oriented interface
 * @export
 * @class AccountInformationApi
 * @extends {BaseAPI}
 */
export class AccountInformationApi extends BaseAPI {
    /**
     * 
     * @summary Get all cash balances of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsAccountIdBalancesGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsAccountIdBalancesGet(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return details of a specific investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account to get detail of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsAccountIdGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsAccountIdGet(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List balances, positions and orders for the specified account.
     * @param {string} accountId The ID of the account to fetch holdings for.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsAccountIdHoldingsGet(accountId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsAccountIdHoldingsGet(accountId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all positions of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsAccountIdPositionsGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsAccountIdPositionsGet(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update details of an investment account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsAccountIdPut(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsAccountIdPut(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all investment accounts for the user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public accountsGet(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).accountsGet(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all accounts for the user, plus balances and positions for each account.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [brokerageAuthorizations] Optional. Comma seperated list of authorization IDs (only use if filtering is needed on one or more authorizations).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountInformationApi
     */
    public holdingsGet(userId: string, userSecret: string, brokerageAuthorizations?: string, options?: AxiosRequestConfig) {
        return AccountInformationApiFp(this.configuration).holdingsGet(userId, userSecret, brokerageAuthorizations, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeDeleteUserDelete: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('snapTradeDeleteUserDelete', 'userId', userId)
            const localVarPath = `/snapTrade/deleteUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeEncryptedJWTGet: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('snapTradeEncryptedJWTGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('snapTradeEncryptedJWTGet', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/encryptedJWT`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeListUsersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapTrade/listUsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeLoginPost: async (userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('snapTradeLoginPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('snapTradeLoginPost', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapTradeLoginUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeRegisterUserPost: async (snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'snapTradeRegisterUserRequestBody' is not null or undefined
            assertParamExists('snapTradeRegisterUserPost', 'snapTradeRegisterUserRequestBody', snapTradeRegisterUserRequestBody)
            const localVarPath = `/snapTrade/registerUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(snapTradeRegisterUserRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeDeleteUserDelete(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeDeleteUserDelete(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeEncryptedJWTGet(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EncryptedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeEncryptedJWTGet(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeListUsersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeListUsersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeLoginPost(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapTradeLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeLoginPost(userId, userSecret, snapTradeLoginUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserIDandSecret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeDeleteUserDelete(userId: string, options?: any): AxiosPromise<DeleteUserResponse> {
            return localVarFp.snapTradeDeleteUserDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeEncryptedJWTGet(userId: string, userSecret: string, options?: any): AxiosPromise<EncryptedResponse> {
            return localVarFp.snapTradeEncryptedJWTGet(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all SnapTrade users you\'ve registered on our platform
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeListUsersGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.snapTradeListUsersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeLoginPost(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: any): AxiosPromise<SnapTradeLoginPost200Response> {
            return localVarFp.snapTradeLoginPost(userId, userSecret, snapTradeLoginUserRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register user with SnapTrade in order to create secure brokerage authorizations
         * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: any): AxiosPromise<UserIDandSecret> {
            return localVarFp.snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Delete user from SnapTrade, disabling all brokerage authorizations and permanently deleting all data associated with the user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public snapTradeDeleteUserDelete(userId: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).snapTradeDeleteUserDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtains an encrypted JWT tokens that should be decrypted on a user\'s local device
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public snapTradeEncryptedJWTGet(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).snapTradeEncryptedJWTGet(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all SnapTrade users you\'ve registered on our platform
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public snapTradeListUsersGet(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).snapTradeListUsersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a redirect URI to securely login a user to the SnapTrade Connection Portal
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {SnapTradeLoginUserRequestBody} [snapTradeLoginUserRequestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public snapTradeLoginPost(userId: string, userSecret: string, snapTradeLoginUserRequestBody?: SnapTradeLoginUserRequestBody, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).snapTradeLoginPost(userId, userSecret, snapTradeLoginUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register user with SnapTrade in order to create secure brokerage authorizations
     * @param {SnapTradeRegisterUserRequestBody} snapTradeRegisterUserRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody: SnapTradeRegisterUserRequestBody, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).snapTradeRegisterUserPost(snapTradeRegisterUserRequestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthorizationIdDelete: async (authorizationId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdDelete', 'authorizationId', authorizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdDelete', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdDelete', 'userSecret', userSecret)
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthorizationIdGet: async (authorizationId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationId' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdGet', 'authorizationId', authorizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('authorizationsAuthorizationIdGet', 'userSecret', userSecret)
            const localVarPath = `/authorizations/{authorizationId}`
                .replace(`{${"authorizationId"}}`, encodeURIComponent(String(authorizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('authorizationsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('authorizationsGet', 'userSecret', userSecret)
            const localVarPath = `/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsAuthorizationIdDelete(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsAuthorizationIdDelete(authorizationId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsAuthorizationIdGet(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrokerageAuthorization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsAuthorizationIdGet(authorizationId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizationsGet(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrokerageAuthorization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizationsGet(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove a brokerage authorization.
         * @param {string} authorizationId The ID of the Authorization to delete.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthorizationIdDelete(authorizationId: string, userId: string, userSecret: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorizationsAuthorizationIdDelete(authorizationId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get detail of a specific brokerage authorizations for the user
         * @param {string} authorizationId The ID of a brokerage authorization object.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsAuthorizationIdGet(authorizationId: string, userId: string, userSecret: string, options?: any): AxiosPromise<BrokerageAuthorization> {
            return localVarFp.authorizationsAuthorizationIdGet(authorizationId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all brokerage authorizations for the user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizationsGet(userId: string, userSecret: string, options?: any): AxiosPromise<Array<BrokerageAuthorization>> {
            return localVarFp.authorizationsGet(userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Remove a brokerage authorization.
     * @param {string} authorizationId The ID of the Authorization to delete.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public authorizationsAuthorizationIdDelete(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).authorizationsAuthorizationIdDelete(authorizationId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get detail of a specific brokerage authorizations for the user
     * @param {string} authorizationId The ID of a brokerage authorization object.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public authorizationsAuthorizationIdGet(authorizationId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).authorizationsAuthorizationIdGet(authorizationId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all brokerage authorizations for the user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectionsApi
     */
    public authorizationsGet(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).authorizationsGet(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ErrorLogsApi - axios parameter creator
 * @export
 */
export const ErrorLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeListUserErrorsGet: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('snapTradeListUserErrorsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('snapTradeListUserErrorsGet', 'userSecret', userSecret)
            const localVarPath = `/snapTrade/listUserErrors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ErrorLogsApi - functional programming interface
 * @export
 */
export const ErrorLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ErrorLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradeListUserErrorsGet(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserErrorLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradeListUserErrorsGet(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ErrorLogsApi - factory interface
 * @export
 */
export const ErrorLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ErrorLogsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve error logs on behalf of your SnapTrade users
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradeListUserErrorsGet(userId: string, userSecret: string, options?: any): AxiosPromise<Array<UserErrorLog>> {
            return localVarFp.snapTradeListUserErrorsGet(userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ErrorLogsApi - object-oriented interface
 * @export
 * @class ErrorLogsApi
 * @extends {BaseAPI}
 */
export class ErrorLogsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve error logs on behalf of your SnapTrade users
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ErrorLogsApi
     */
    public snapTradeListUserErrorsGet(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return ErrorLogsApiFp(this.configuration).snapTradeListUserErrorsGet(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OptionsApi - axios parameter creator
 * @export
 */
export const OptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol brokerage symbol to get quotes for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsChainGet: async (userId: string, userSecret: string, accountId: string, symbol: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsChainGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdOptionsChainGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsChainGet', 'accountId', accountId)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('accountsAccountIdOptionsChainGet', 'symbol', symbol)
            const localVarPath = `/accounts/{accountId}/options_chain`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsGet: async (userId: string, userSecret: string, accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdOptionsGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/options`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for more specific option quotes from option chain. Date is required but can filter by min, max or min-max.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} date The date of the options you are searching for. Will return closest date that has not passed. Format- [YYYY-MM-DD]
         * @param {number} [minStrike] The minimum strike price for the desired contract
         * @param {number} [maxStrike] The max strike price for the desired contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsSearchGet: async (userId: string, userSecret: string, accountId: string, date: string, minStrike?: number, maxStrike?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsSearchGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdOptionsSearchGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdOptionsSearchGet', 'accountId', accountId)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('accountsAccountIdOptionsSearchGet', 'date', date)
            const localVarPath = `/accounts/{accountId}/options_search`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (date !== undefined) {
                localVarQueryParameter['Date'] = date;
            }

            if (minStrike !== undefined) {
                localVarQueryParameter['min_strike'] = minStrike;
            }

            if (maxStrike !== undefined) {
                localVarQueryParameter['max_strike'] = maxStrike;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a strategies impact on the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {{ [key: string]: any; }} strategyQuotesRecord The strategy quotes record returned from the strategy_quotes endpoint
         * @param {string} body 
         * @param {number} [strikePrice] The strike price, only needed if the order is a limit order
         * @param {string} [primaryRoute] The desired route for the order, default is \&quot;AUTO\&quot;
         * @param {string} [secondarRoute] The desired secondary route for the order, default is \&quot;AUTO\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyImpactPost: async (userId: string, userSecret: string, accountId: string, strategyQuotesRecord: { [key: string]: any; }, body: string, strikePrice?: number, primaryRoute?: string, secondarRoute?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyImpactPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdStrategyImpactPost', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyImpactPost', 'accountId', accountId)
            // verify required parameter 'strategyQuotesRecord' is not null or undefined
            assertParamExists('accountsAccountIdStrategyImpactPost', 'strategyQuotesRecord', strategyQuotesRecord)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAccountIdStrategyImpactPost', 'body', body)
            const localVarPath = `/accounts/{accountId}/strategy_impact`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (strategyQuotesRecord !== undefined) {
                localVarQueryParameter['StrategyQuotesRecord'] = strategyQuotesRecord;
            }

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (primaryRoute !== undefined) {
                localVarQueryParameter['primary_route'] = primaryRoute;
            }

            if (secondarRoute !== undefined) {
                localVarQueryParameter['secondar_route'] = secondarRoute;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place the strategy order; impact not required but the StrategyOrderQuotes object is
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} strategyOrder 
         * @param {number} strikePrice 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {number} [primaryRoute] 
         * @param {number} [secondaryRoute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyPlacePost: async (userId: string, userSecret: string, strategyOrder: number, strikePrice: number, accountId: string, body: string, primaryRoute?: number, secondaryRoute?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'userSecret', userSecret)
            // verify required parameter 'strategyOrder' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'strategyOrder', strategyOrder)
            // verify required parameter 'strikePrice' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'strikePrice', strikePrice)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAccountIdStrategyPlacePost', 'body', body)
            const localVarPath = `/accounts/{accountId}/strategy_place`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (strategyOrder !== undefined) {
                localVarQueryParameter['strategy_order'] = strategyOrder;
            }

            if (strikePrice !== undefined) {
                localVarQueryParameter['strike_price'] = strikePrice;
            }

            if (primaryRoute !== undefined) {
                localVarQueryParameter['primary_route'] = primaryRoute;
            }

            if (secondaryRoute !== undefined) {
                localVarQueryParameter['secondary_route'] = secondaryRoute;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a price quote for a strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} legs 
         * @param {string} strategy 
         * @param {string} timeInForce 
         * @param {string} orderType 
         * @param {string} accountId The ID of the account get positions.
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyQuotesPost: async (userId: string, userSecret: string, legs: number, strategy: string, timeInForce: string, orderType: string, accountId: string, manualTradeForm: ManualTradeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'userSecret', userSecret)
            // verify required parameter 'legs' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'legs', legs)
            // verify required parameter 'strategy' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'strategy', strategy)
            // verify required parameter 'timeInForce' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'timeInForce', timeInForce)
            // verify required parameter 'orderType' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'orderType', orderType)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'accountId', accountId)
            // verify required parameter 'manualTradeForm' is not null or undefined
            assertParamExists('accountsAccountIdStrategyQuotesPost', 'manualTradeForm', manualTradeForm)
            const localVarPath = `/accounts/{accountId}/strategy_quotes`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (legs !== undefined) {
                localVarQueryParameter['legs'] = legs;
            }

            if (strategy !== undefined) {
                localVarQueryParameter['strategy'] = strategy;
            }

            if (timeInForce !== undefined) {
                localVarQueryParameter['time_in_force'] = timeInForce;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['order_type'] = orderType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OptionsApi - functional programming interface
 * @export
 */
export const OptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol brokerage symbol to get quotes for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdOptionsChainGet(userId: string, userSecret: string, accountId: string, symbol: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionChainInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdOptionsChainGet(userId, userSecret, accountId, symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdOptionsGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OptionsHoldings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdOptionsGet(userId, userSecret, accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for more specific option quotes from option chain. Date is required but can filter by min, max or min-max.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} date The date of the options you are searching for. Will return closest date that has not passed. Format- [YYYY-MM-DD]
         * @param {number} [minStrike] The minimum strike price for the desired contract
         * @param {number} [maxStrike] The max strike price for the desired contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdOptionsSearchGet(userId: string, userSecret: string, accountId: string, date: string, minStrike?: number, maxStrike?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OptionChainInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdOptionsSearchGet(userId, userSecret, accountId, date, minStrike, maxStrike, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a strategies impact on the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {{ [key: string]: any; }} strategyQuotesRecord The strategy quotes record returned from the strategy_quotes endpoint
         * @param {string} body 
         * @param {number} [strikePrice] The strike price, only needed if the order is a limit order
         * @param {string} [primaryRoute] The desired route for the order, default is \&quot;AUTO\&quot;
         * @param {string} [secondarRoute] The desired secondary route for the order, default is \&quot;AUTO\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdStrategyImpactPost(userId: string, userSecret: string, accountId: string, strategyQuotesRecord: { [key: string]: any; }, body: string, strikePrice?: number, primaryRoute?: string, secondarRoute?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyImpact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdStrategyImpactPost(userId, userSecret, accountId, strategyQuotesRecord, body, strikePrice, primaryRoute, secondarRoute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place the strategy order; impact not required but the StrategyOrderQuotes object is
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} strategyOrder 
         * @param {number} strikePrice 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {number} [primaryRoute] 
         * @param {number} [secondaryRoute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdStrategyPlacePost(userId: string, userSecret: string, strategyOrder: number, strikePrice: number, accountId: string, body: string, primaryRoute?: number, secondaryRoute?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyOrderPlace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdStrategyPlacePost(userId, userSecret, strategyOrder, strikePrice, accountId, body, primaryRoute, secondaryRoute, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a price quote for a strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} legs 
         * @param {string} strategy 
         * @param {string} timeInForce 
         * @param {string} orderType 
         * @param {string} accountId The ID of the account get positions.
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdStrategyQuotesPost(userId: string, userSecret: string, legs: number, strategy: string, timeInForce: string, orderType: string, accountId: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdStrategyQuotesPost(userId, userSecret, legs, strategy, timeInForce, orderType, accountId, manualTradeForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OptionsApi - factory interface
 * @export
 */
export const OptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OptionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the options chain
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} symbol brokerage symbol to get quotes for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsChainGet(userId: string, userSecret: string, accountId: string, symbol: string, options?: any): AxiosPromise<Array<OptionChainInner>> {
            return localVarFp.accountsAccountIdOptionsChainGet(userId, userSecret, accountId, symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the options holdings in the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsGet(userId: string, userSecret: string, accountId: string, options?: any): AxiosPromise<OptionsHoldings> {
            return localVarFp.accountsAccountIdOptionsGet(userId, userSecret, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for more specific option quotes from option chain. Date is required but can filter by min, max or min-max.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} date The date of the options you are searching for. Will return closest date that has not passed. Format- [YYYY-MM-DD]
         * @param {number} [minStrike] The minimum strike price for the desired contract
         * @param {number} [maxStrike] The max strike price for the desired contract
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOptionsSearchGet(userId: string, userSecret: string, accountId: string, date: string, minStrike?: number, maxStrike?: number, options?: any): AxiosPromise<Array<OptionChainInner>> {
            return localVarFp.accountsAccountIdOptionsSearchGet(userId, userSecret, accountId, date, minStrike, maxStrike, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a strategies impact on the account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {{ [key: string]: any; }} strategyQuotesRecord The strategy quotes record returned from the strategy_quotes endpoint
         * @param {string} body 
         * @param {number} [strikePrice] The strike price, only needed if the order is a limit order
         * @param {string} [primaryRoute] The desired route for the order, default is \&quot;AUTO\&quot;
         * @param {string} [secondarRoute] The desired secondary route for the order, default is \&quot;AUTO\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyImpactPost(userId: string, userSecret: string, accountId: string, strategyQuotesRecord: { [key: string]: any; }, body: string, strikePrice?: number, primaryRoute?: string, secondarRoute?: string, options?: any): AxiosPromise<StrategyImpact> {
            return localVarFp.accountsAccountIdStrategyImpactPost(userId, userSecret, accountId, strategyQuotesRecord, body, strikePrice, primaryRoute, secondarRoute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place the strategy order; impact not required but the StrategyOrderQuotes object is
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} strategyOrder 
         * @param {number} strikePrice 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {number} [primaryRoute] 
         * @param {number} [secondaryRoute] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyPlacePost(userId: string, userSecret: string, strategyOrder: number, strikePrice: number, accountId: string, body: string, primaryRoute?: number, secondaryRoute?: number, options?: any): AxiosPromise<StrategyOrderPlace> {
            return localVarFp.accountsAccountIdStrategyPlacePost(userId, userSecret, strategyOrder, strikePrice, accountId, body, primaryRoute, secondaryRoute, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a price quote for a strategy
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {number} legs 
         * @param {string} strategy 
         * @param {string} timeInForce 
         * @param {string} orderType 
         * @param {string} accountId The ID of the account get positions.
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdStrategyQuotesPost(userId: string, userSecret: string, legs: number, strategy: string, timeInForce: string, orderType: string, accountId: string, manualTradeForm: ManualTradeForm, options?: any): AxiosPromise<any> {
            return localVarFp.accountsAccountIdStrategyQuotesPost(userId, userSecret, legs, strategy, timeInForce, orderType, accountId, manualTradeForm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OptionsApi - object-oriented interface
 * @export
 * @class OptionsApi
 * @extends {BaseAPI}
 */
export class OptionsApi extends BaseAPI {
    /**
     * 
     * @summary Get the options chain
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} symbol brokerage symbol to get quotes for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdOptionsChainGet(userId: string, userSecret: string, accountId: string, symbol: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdOptionsChainGet(userId, userSecret, accountId, symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the options holdings in the account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdOptionsGet(userId: string, userSecret: string, accountId: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdOptionsGet(userId, userSecret, accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for more specific option quotes from option chain. Date is required but can filter by min, max or min-max.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} date The date of the options you are searching for. Will return closest date that has not passed. Format- [YYYY-MM-DD]
     * @param {number} [minStrike] The minimum strike price for the desired contract
     * @param {number} [maxStrike] The max strike price for the desired contract
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdOptionsSearchGet(userId: string, userSecret: string, accountId: string, date: string, minStrike?: number, maxStrike?: number, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdOptionsSearchGet(userId, userSecret, accountId, date, minStrike, maxStrike, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a strategies impact on the account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {{ [key: string]: any; }} strategyQuotesRecord The strategy quotes record returned from the strategy_quotes endpoint
     * @param {string} body 
     * @param {number} [strikePrice] The strike price, only needed if the order is a limit order
     * @param {string} [primaryRoute] The desired route for the order, default is \&quot;AUTO\&quot;
     * @param {string} [secondarRoute] The desired secondary route for the order, default is \&quot;AUTO\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdStrategyImpactPost(userId: string, userSecret: string, accountId: string, strategyQuotesRecord: { [key: string]: any; }, body: string, strikePrice?: number, primaryRoute?: string, secondarRoute?: string, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdStrategyImpactPost(userId, userSecret, accountId, strategyQuotesRecord, body, strikePrice, primaryRoute, secondarRoute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place the strategy order; impact not required but the StrategyOrderQuotes object is
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {number} strategyOrder 
     * @param {number} strikePrice 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} body 
     * @param {number} [primaryRoute] 
     * @param {number} [secondaryRoute] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdStrategyPlacePost(userId: string, userSecret: string, strategyOrder: number, strikePrice: number, accountId: string, body: string, primaryRoute?: number, secondaryRoute?: number, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdStrategyPlacePost(userId, userSecret, strategyOrder, strikePrice, accountId, body, primaryRoute, secondaryRoute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a price quote for a strategy
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {number} legs 
     * @param {string} strategy 
     * @param {string} timeInForce 
     * @param {string} orderType 
     * @param {string} accountId The ID of the account get positions.
     * @param {ManualTradeForm} manualTradeForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OptionsApi
     */
    public accountsAccountIdStrategyQuotesPost(userId: string, userSecret: string, legs: number, strategy: string, timeInForce: string, orderType: string, accountId: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig) {
        return OptionsApiFp(this.configuration).accountsAccountIdStrategyQuotesPost(userId, userSecret, legs, strategy, timeInForce, orderType, accountId, manualTradeForm, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortfolioManagementApi - axios parameter creator
 * @export
 */
export const PortfolioManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelAssetClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdDelete: async (modelAssetClassId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('modelAssetClassModelAssetClassIdDelete', 'modelAssetClassId', modelAssetClassId)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdGet: async (modelAssetClassId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('modelAssetClassModelAssetClassIdGet', 'modelAssetClassId', modelAssetClassId)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdPost: async (modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelAssetClassId' is not null or undefined
            assertParamExists('modelAssetClassModelAssetClassIdPost', 'modelAssetClassId', modelAssetClassId)
            // verify required parameter 'modelAssetClassDetails' is not null or undefined
            assertParamExists('modelAssetClassModelAssetClassIdPost', 'modelAssetClassDetails', modelAssetClassDetails)
            const localVarPath = `/modelAssetClass/{modelAssetClassId}`
                .replace(`{${"modelAssetClassId"}}`, encodeURIComponent(String(modelAssetClassId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelAssetClassDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelAssetClass`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelPortfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdDelete: async (modelPortfolioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('modelPortfolioModelPortfolioIdDelete', 'modelPortfolioId', modelPortfolioId)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdGet: async (modelPortfolioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('modelPortfolioModelPortfolioIdGet', 'modelPortfolioId', modelPortfolioId)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdPost: async (modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelPortfolioId' is not null or undefined
            assertParamExists('modelPortfolioModelPortfolioIdPost', 'modelPortfolioId', modelPortfolioId)
            // verify required parameter 'modelPortfolioDetails' is not null or undefined
            assertParamExists('modelPortfolioModelPortfolioIdPost', 'modelPortfolioDetails', modelPortfolioDetails)
            const localVarPath = `/modelPortfolio/{modelPortfolioId}`
                .replace(`{${"modelPortfolioId"}}`, encodeURIComponent(String(modelPortfolioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelPortfolioDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/modelPortfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsGet: async (userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('portfolioGroupsGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('portfolioGroupsGet', 'userSecret', userSecret)
            const localVarPath = `/portfolioGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdAccountsGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdAccountsGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/accounts`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdBalancesGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdBalancesGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/balances`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/{TradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"TradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdDelete: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdDelete', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdExcludedassetsGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsPost: async (portfolioGroupId: string, universalSymbol?: UniversalSymbol, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdExcludedassetsPost', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(universalSymbol, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete: async (portfolioGroupId: string, symbolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'symbolId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete', 'symbolId', symbolId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/excludedassets/{symbolId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"symbolId"}}`, encodeURIComponent(String(symbolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdImportPost: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdImportPost', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/import`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdInfoGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdInfoGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/info`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdPatch: async (portfolioGroupId: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdPatch', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdPatch', 'requestBody', requestBody)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdPositionsGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdPositionsGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/positions`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSettingsGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdSettingsGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/settings`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSettingsPatch: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdSettingsPatch', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/settings`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSymbolsPost: async (portfolioGroupId: string, symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdSymbolsPost', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/symbols`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsGet: async (portfolioGroupId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsGet', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsPost: async (portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsPost', 'portfolioGroupId', portfolioGroupId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete: async (portfolioGroupId: string, targetAssetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete', 'targetAssetId', targetAssetId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet: async (portfolioGroupId: string, targetAssetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet', 'targetAssetId', targetAssetId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch: async (portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'targetAssetId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch', 'targetAssetId', targetAssetId)
            // verify required parameter 'targetAsset' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch', 'targetAsset', targetAsset)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/targets/{targetAssetId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"targetAssetId"}}`, encodeURIComponent(String(targetAssetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetAsset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPost: async (userId: string, userSecret: string, requestBody: { [key: string]: any; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('portfolioGroupsPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('portfolioGroupsPost', 'userSecret', userSecret)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('portfolioGroupsPost', 'requestBody', requestBody)
            const localVarPath = `/portfolioGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioManagementApi - functional programming interface
 * @export
 */
export const PortfolioManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelAssetClassGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelAssetClassDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelAssetClassGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelAssetClassModelAssetClassIdDelete(modelAssetClassId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelAssetClassModelAssetClassIdDelete(modelAssetClassId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelAssetClassModelAssetClassIdGet(modelAssetClassId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAssetClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelAssetClassModelAssetClassIdGet(modelAssetClassId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelAssetClassModelAssetClassIdPost(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelAssetClassModelAssetClassIdPost(modelAssetClassId, modelAssetClassDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelAssetClassPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelAssetClassDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelAssetClassPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelPortfolioGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelPortfolioDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelPortfolioGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelPortfolioModelPortfolioIdDelete(modelPortfolioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelPortfolioModelPortfolioIdDelete(modelPortfolioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelPortfolioModelPortfolioIdGet(modelPortfolioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelPortfolioDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelPortfolioModelPortfolioIdGet(modelPortfolioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelPortfolioModelPortfolioIdPost(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelPortfolioModelPortfolioIdPost(modelPortfolioId, modelPortfolioDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelPortfolioPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelPortfolioDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelPortfolioPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsGet(userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsGet(userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Balance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculatedTrade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExcludedAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExcludedAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId, universalSymbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId: string, symbolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId, symbolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroupPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortfolioGroupSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId, symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TargetAsset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId, targetAsset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId, targetAssetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId, targetAssetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetAsset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId, targetAssetId, targetAsset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPost(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortfolioGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPost(userId, userSecret, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortfolioManagementApi - factory interface
 * @export
 */
export const PortfolioManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary List of model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassGet(options?: any): AxiosPromise<Array<ModelAssetClassDetails>> {
            return localVarFp.modelAssetClassGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdDelete(modelAssetClassId: string, options?: any): AxiosPromise<void> {
            return localVarFp.modelAssetClassModelAssetClassIdDelete(modelAssetClassId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a model asset class
         * @param {string} modelAssetClassId The ID of the model asset class to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdGet(modelAssetClassId: string, options?: any): AxiosPromise<ModelAssetClassDetails> {
            return localVarFp.modelAssetClassModelAssetClassIdGet(modelAssetClassId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates model asset class objects
         * @param {string} modelAssetClassId The ID of the model asset class to update.
         * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassModelAssetClassIdPost(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: any): AxiosPromise<void> {
            return localVarFp.modelAssetClassModelAssetClassIdPost(modelAssetClassId, modelAssetClassDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new model asset class
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelAssetClassPost(options?: any): AxiosPromise<ModelAssetClassDetails> {
            return localVarFp.modelAssetClassPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioGet(options?: any): AxiosPromise<Array<ModelPortfolioDetails>> {
            return localVarFp.modelPortfolioGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdDelete(modelPortfolioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.modelPortfolioModelPortfolioIdDelete(modelPortfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a model portfolio
         * @param {string} modelPortfolioId The ID of the model portfolio to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdGet(modelPortfolioId: string, options?: any): AxiosPromise<ModelPortfolioDetails> {
            return localVarFp.modelPortfolioModelPortfolioIdGet(modelPortfolioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates model portfolio object
         * @param {string} modelPortfolioId The ID of the model portfolio to update.
         * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioModelPortfolioIdPost(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: any): AxiosPromise<void> {
            return localVarFp.modelPortfolioModelPortfolioIdPost(modelPortfolioId, modelPortfolioDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new model portfolio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelPortfolioPost(options?: any): AxiosPromise<ModelPortfolioDetails> {
            return localVarFp.modelPortfolioPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all portfolio groups
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsGet(userId: string, userSecret: string, options?: any): AxiosPromise<Array<PortfolioGroup>> {
            return localVarFp.portfolioGroupsGet(userId, userSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all accounts associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId: string, options?: any): AxiosPromise<Array<Account>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get sum of cash balances in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId: string, options?: any): AxiosPromise<Array<Balance>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: any): AxiosPromise<Trade> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return an individual trade
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: any): AxiosPromise<Array<Trade>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of trades to make to rebalance portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId: string, options?: any): AxiosPromise<CalculatedTrade> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an array of excluded assets associated with a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId: string, options?: any): AxiosPromise<Array<ExcludedAsset>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an asset to exclude to a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
         * @param {UniversalSymbol} [universalSymbol] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: any): AxiosPromise<ExcludedAsset> {
            return localVarFp.portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId, universalSymbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unexclude an asset from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
         * @param {string} symbolId The ID of the excluded asset Symbol to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId: string, symbolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId, symbolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a target portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdGet(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.portfolioGroupsPortfolioGroupIdGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import target allocation based on portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId: string, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return a whole bunch of relevant information relating to a portfolio group.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupInfo> {
            return localVarFp.portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing target portfolio.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<PortfolioGroup> {
            return localVarFp.portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get total of each postions owned in portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId: string, options?: any): AxiosPromise<Array<PortfolioGroupPosition>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupSettings> {
            return localVarFp.portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates portfolio group settings
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId: string, options?: any): AxiosPromise<PortfolioGroupSettings> {
            return localVarFp.portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for symbols limited to brokerages under the specified portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId, symbolQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all target assets under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId: string, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
         * @param {Array<TargetAsset>} [targetAsset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: any): AxiosPromise<Array<TargetAsset>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId, targetAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a TargetAsset.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId: string, targetAssetId: string, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId, targetAssetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific target from a portfolio group
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId: string, targetAssetId: string, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId, targetAssetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a TargetAsset under the specified PortfolioGroup.
         * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
         * @param {string} targetAssetId The ID of the TargetAsset to patch.
         * @param {TargetAsset} targetAsset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: any): AxiosPromise<TargetAsset> {
            return localVarFp.portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId, targetAssetId, targetAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new portfolio group
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {{ [key: string]: any; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPost(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<Array<PortfolioGroup>> {
            return localVarFp.portfolioGroupsPost(userId, userSecret, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortfolioManagementApi - object-oriented interface
 * @export
 * @class PortfolioManagementApi
 * @extends {BaseAPI}
 */
export class PortfolioManagementApi extends BaseAPI {
    /**
     * 
     * @summary List of model asset class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelAssetClassGet(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelAssetClassGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a model asset class
     * @param {string} modelAssetClassId The ID of the model asset class to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelAssetClassModelAssetClassIdDelete(modelAssetClassId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelAssetClassModelAssetClassIdDelete(modelAssetClassId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a model asset class
     * @param {string} modelAssetClassId The ID of the model asset class to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelAssetClassModelAssetClassIdGet(modelAssetClassId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelAssetClassModelAssetClassIdGet(modelAssetClassId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates model asset class objects
     * @param {string} modelAssetClassId The ID of the model asset class to update.
     * @param {ModelAssetClassDetails} modelAssetClassDetails Use this endpoint change model asset class name and to add or remove a model asset class target. &lt;br /&gt;&lt;br /&gt; * Only the model asset class name is required for the model asset class object. &lt;br /&gt; * Only the symbol id is required for the symbol object in the model asset class target object. &lt;br /&gt; * To remove all model asset class targets, set the model asset class target as an empty array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelAssetClassModelAssetClassIdPost(modelAssetClassId: string, modelAssetClassDetails: ModelAssetClassDetails, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelAssetClassModelAssetClassIdPost(modelAssetClassId, modelAssetClassDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new model asset class
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelAssetClassPost(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelAssetClassPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of model portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelPortfolioGet(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelPortfolioGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a model portfolio
     * @param {string} modelPortfolioId The ID of the model portfolio to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelPortfolioModelPortfolioIdDelete(modelPortfolioId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelPortfolioModelPortfolioIdDelete(modelPortfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a model portfolio
     * @param {string} modelPortfolioId The ID of the model portfolio to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelPortfolioModelPortfolioIdGet(modelPortfolioId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelPortfolioModelPortfolioIdGet(modelPortfolioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates model portfolio object
     * @param {string} modelPortfolioId The ID of the model portfolio to update.
     * @param {ModelPortfolioDetails} modelPortfolioDetails Use this endpoint change model asset class name and to add or remove a model portfolio security/model portfolio asset class. &lt;br /&gt;&lt;br /&gt; * The model portfolio name and model portfolio model type is required. &lt;br /&gt; * The model portfolio model type must be either 0 or 1. [0 -&gt; Securities based, 1 -&gt; Asset Class based] &lt;br /&gt;&lt;br /&gt; * If the model portfolio type is 0, the model portfolio asset class must be an empty array. &lt;br /&gt; * If the model portfolio type is 1, the model portfolio security must be an empty array. &lt;br /&gt;&lt;br /&gt; * When updating the model portfolio security, the percent is required. Only the symbol id is required for the symbol object &lt;br /&gt; * When updating the model portfolio asset classes, the percent is required. Only the model asset class id is required for the model asset class object &lt;br /&gt;&lt;br /&gt; * To remove all model portfolio securities or model portfolio asset class, set then to an empty array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelPortfolioModelPortfolioIdPost(modelPortfolioId: string, modelPortfolioDetails: ModelPortfolioDetails, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelPortfolioModelPortfolioIdPost(modelPortfolioId, modelPortfolioDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new model portfolio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public modelPortfolioPost(options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).modelPortfolioPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all portfolio groups
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsGet(userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsGet(userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all accounts associated with a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the accounts are linked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdAccountsGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get sum of cash balances in portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdBalancesGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return details of a specific trade before it\'s placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify units of a trade before it is placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {Trade} [trade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return an individual trade
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of trades to make to rebalance portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a target portfolio.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdDelete(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an array of excluded assets associated with a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which the excluded assets are linked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdExcludedassetsGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an asset to exclude to a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to exclude an asset.
     * @param {UniversalSymbol} [universalSymbol] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId: string, universalSymbol?: UniversalSymbol, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdExcludedassetsPost(portfolioGroupId, universalSymbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unexclude an asset from a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to unexclude an asset.
     * @param {string} symbolId The ID of the excluded asset Symbol to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId: string, symbolId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdExcludedassetsSymbolIdDelete(portfolioGroupId, symbolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a target portfolio
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import target allocation based on portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdImportPost(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return a whole bunch of relevant information relating to a portfolio group.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdInfoGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing target portfolio.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to update.
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdPatch(portfolioGroupId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get total of each postions owned in portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdPositionsGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get portfolio group settings
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdSettingsGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates portfolio group settings
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdSettingsPatch(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for symbols limited to brokerages under the specified portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to search under
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdSymbolsPost(portfolioGroupId, symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all target assets under the specified PortfolioGroup.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdTargetsGet(portfolioGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set a new list of target assets under the specified PortfolioGroup. All existing target assets under this portfolio group will be replaced with the new list.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to create the target asset.
     * @param {Array<TargetAsset>} [targetAsset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId: string, targetAsset?: Array<TargetAsset>, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdTargetsPost(portfolioGroupId, targetAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a TargetAsset.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to remove the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdDelete(portfolioGroupId, targetAssetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific target from a portfolio group
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to get the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId: string, targetAssetId: string, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdGet(portfolioGroupId, targetAssetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a TargetAsset under the specified PortfolioGroup.
     * @param {string} portfolioGroupId The ID of the PortfolioGroup under which to patch the target asset.
     * @param {string} targetAssetId The ID of the TargetAsset to patch.
     * @param {TargetAsset} targetAsset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId: string, targetAssetId: string, targetAsset: TargetAsset, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPortfolioGroupIdTargetsTargetAssetIdPatch(portfolioGroupId, targetAssetId, targetAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new portfolio group
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioManagementApi
     */
    public portfolioGroupsPost(userId: string, userSecret: string, requestBody: { [key: string]: any; }, options?: AxiosRequestConfig) {
        return PortfolioManagementApiFp(this.configuration).portfolioGroupsPost(userId, userSecret, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferenceDataApi - axios parameter creator
 * @export
 */
export const ReferenceDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdSymbolsPost: async (userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdSymbolsPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdSymbolsPost', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdSymbolsPost', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/symbols`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brokerageAuthorizationTypesGet: async (brokerage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerageAuthorizationTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (brokerage !== undefined) {
                localVarQueryParameter['brokerage'] = brokerage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brokeragesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesRatesCurrencyPairGet: async (currencyPair: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyPair' is not null or undefined
            assertParamExists('currenciesRatesCurrencyPairGet', 'currencyPair', currencyPair)
            const localVarPath = `/currencies/rates/{currencyPair}`
                .replace(`{${"currencyPair"}}`, encodeURIComponent(String(currencyPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesRatesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies/rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityTypesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/securityTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradePartnersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapTrade/partners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsPost: async (symbolQuery?: SymbolQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/symbols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(symbolQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a symbol
         * @param {string} symbolId The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsSymbolIdGet: async (symbolId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbolId' is not null or undefined
            assertParamExists('symbolsSymbolIdGet', 'symbolId', symbolId)
            const localVarPath = `/symbols/{symbolId}`
                .replace(`{${"symbolId"}}`, encodeURIComponent(String(symbolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsTickerGet: async (ticker: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('symbolsTickerGet', 'ticker', ticker)
            const localVarPath = `/symbols/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceDataApi - functional programming interface
 * @export
 */
export const ReferenceDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferenceDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdSymbolsPost(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdSymbolsPost(userId, userSecret, accountId, symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brokerageAuthorizationTypesGet(brokerage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrokerageAuthorizationTypeReadOnly>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brokerageAuthorizationTypesGet(brokerage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async brokeragesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brokerage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.brokeragesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Currency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesRatesCurrencyPairGet(currencyPair: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeRatePairs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesRatesCurrencyPairGet(currencyPair, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currenciesRatesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExchangeRatePairs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currenciesRatesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exchangesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Exchange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exchangesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityTypesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SecurityType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityTypesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async snapTradePartnersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PartnerData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.snapTradePartnersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async symbolsPost(symbolQuery?: SymbolQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSymbol>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.symbolsPost(symbolQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a symbol
         * @param {string} symbolId The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async symbolsSymbolIdGet(symbolId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniversalSymbol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.symbolsSymbolIdGet(symbolId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async symbolsTickerGet(ticker: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniversalSymbol>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.symbolsTickerGet(ticker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferenceDataApi - factory interface
 * @export
 */
export const ReferenceDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferenceDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Search for symbols that are supported by a brokerage account using a substring
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdSymbolsPost(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.accountsAccountIdSymbolsPost(userId, userSecret, accountId, symbolQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all brokerage authorization types
         * @param {string} [brokerage] Comma separated value of brokerage slugs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brokerageAuthorizationTypesGet(brokerage?: string, options?: any): AxiosPromise<Array<BrokerageAuthorizationTypeReadOnly>> {
            return localVarFp.brokerageAuthorizationTypesGet(brokerage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all brokerages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        brokeragesGet(options?: any): AxiosPromise<Array<Brokerage>> {
            return localVarFp.brokeragesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesGet(options?: any): AxiosPromise<Array<Currency>> {
            return localVarFp.currenciesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the exchange rate of a currency pair
         * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesRatesCurrencyPairGet(currencyPair: string, options?: any): AxiosPromise<ExchangeRatePairs> {
            return localVarFp.currenciesRatesCurrencyPairGet(currencyPair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the exchange rates of all supported currencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currenciesRatesGet(options?: any): AxiosPromise<Array<ExchangeRatePairs>> {
            return localVarFp.currenciesRatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return list of stock exchanges on Passiv and their suffixes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exchangesGet(options?: any): AxiosPromise<Array<Exchange>> {
            return localVarFp.exchangesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of all security types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityTypesGet(options?: any): AxiosPromise<Array<SecurityType>> {
            return localVarFp.securityTypesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata related to Snaptrade partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        snapTradePartnersGet(options?: any): AxiosPromise<PartnerData> {
            return localVarFp.snapTradePartnersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for symbols
         * @param {SymbolQuery} [symbolQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsPost(symbolQuery?: SymbolQuery, options?: any): AxiosPromise<Array<UniversalSymbol>> {
            return localVarFp.symbolsPost(symbolQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a symbol
         * @param {string} symbolId The ID of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsSymbolIdGet(symbolId: string, options?: any): AxiosPromise<UniversalSymbol> {
            return localVarFp.symbolsSymbolIdGet(symbolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a symbol by the ticker
         * @param {string} ticker The ticker of the UniversalSymbol to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        symbolsTickerGet(ticker: string, options?: any): AxiosPromise<UniversalSymbol> {
            return localVarFp.symbolsTickerGet(ticker, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferenceDataApi - object-oriented interface
 * @export
 * @class ReferenceDataApi
 * @extends {BaseAPI}
 */
export class ReferenceDataApi extends BaseAPI {
    /**
     * 
     * @summary Search for symbols that are supported by a brokerage account using a substring
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public accountsAccountIdSymbolsPost(userId: string, userSecret: string, accountId: string, symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).accountsAccountIdSymbolsPost(userId, userSecret, accountId, symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all brokerage authorization types
     * @param {string} [brokerage] Comma separated value of brokerage slugs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public brokerageAuthorizationTypesGet(brokerage?: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).brokerageAuthorizationTypesGet(brokerage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all brokerages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public brokeragesGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).brokeragesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all supported currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public currenciesGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).currenciesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the exchange rate of a currency pair
     * @param {string} currencyPair A currency pair based on currency code for example, {CAD-USD}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public currenciesRatesCurrencyPairGet(currencyPair: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).currenciesRatesCurrencyPairGet(currencyPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the exchange rates of all supported currencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public currenciesRatesGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).currenciesRatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return list of stock exchanges on Passiv and their suffixes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public exchangesGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).exchangesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of all security types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public securityTypesGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).securityTypesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata related to Snaptrade partner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public snapTradePartnersGet(options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).snapTradePartnersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for symbols
     * @param {SymbolQuery} [symbolQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public symbolsPost(symbolQuery?: SymbolQuery, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).symbolsPost(symbolQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a symbol
     * @param {string} symbolId The ID of the UniversalSymbol to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public symbolsSymbolIdGet(symbolId: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).symbolsSymbolIdGet(symbolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a symbol by the ticker
     * @param {string} ticker The ticker of the UniversalSymbol to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceDataApi
     */
    public symbolsTickerGet(ticker: string, options?: AxiosRequestConfig) {
        return ReferenceDataApiFp(this.configuration).symbolsTickerGet(ticker, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TradingApi - axios parameter creator
 * @export
 */
export const TradingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOrdersCancelPost: async (userId: string, userSecret: string, accountId: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdOrdersCancelPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdOrdersCancelPost', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdOrdersCancelPost', 'accountId', accountId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('accountsAccountIdOrdersCancelPost', 'body', body)
            const localVarPath = `/accounts/{accountId}/orders/cancel`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOrdersGet: async (userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdOrdersGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdOrdersGet', 'userSecret', userSecret)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdOrdersGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/orders`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdQuotesGet: async (userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('accountsAccountIdQuotesGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('accountsAccountIdQuotesGet', 'userSecret', userSecret)
            // verify required parameter 'symbols' is not null or undefined
            assertParamExists('accountsAccountIdQuotesGet', 'symbols', symbols)
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('accountsAccountIdQuotesGet', 'accountId', accountId)
            const localVarPath = `/accounts/{accountId}/quotes`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }

            if (symbols !== undefined) {
                localVarQueryParameter['symbols'] = symbols;
            }

            if (useTicker !== undefined) {
                localVarQueryParameter['use_ticker'] = useTicker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet: async (portfolioGroupId: string, calculatedTradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet', 'calculatedTradeId', calculatedTradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/impact`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch: async (portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'calculatedTradeId', calculatedTradeId)
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch', 'tradeId', tradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/modify/{tradeId}`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)))
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trade, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost: async (portfolioGroupId: string, calculatedTradeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portfolioGroupId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost', 'portfolioGroupId', portfolioGroupId)
            // verify required parameter 'calculatedTradeId' is not null or undefined
            assertParamExists('portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost', 'calculatedTradeId', calculatedTradeId)
            const localVarPath = `/portfolioGroups/{portfolioGroupId}/calculatedtrades/{calculatedTradeId}/placeOrders`
                .replace(`{${"portfolioGroupId"}}`, encodeURIComponent(String(portfolioGroupId)))
                .replace(`{${"calculatedTradeId"}}`, encodeURIComponent(String(calculatedTradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeImpactPost: async (userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('tradeImpactPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('tradeImpactPost', 'userSecret', userSecret)
            // verify required parameter 'manualTradeForm' is not null or undefined
            assertParamExists('tradeImpactPost', 'manualTradeForm', manualTradeForm)
            const localVarPath = `/trade/impact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manualTradeForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradeOcoPostRequest} tradeOcoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeOcoPost: async (userId: string, userSecret: string, tradeOcoPostRequest: TradeOcoPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('tradeOcoPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('tradeOcoPost', 'userSecret', userSecret)
            // verify required parameter 'tradeOcoPostRequest' is not null or undefined
            assertParamExists('tradeOcoPost', 'tradeOcoPostRequest', tradeOcoPostRequest)
            const localVarPath = `/trade/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tradeOcoPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeTradeIdPost: async (tradeId: string, userId: string, userSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tradeId' is not null or undefined
            assertParamExists('tradeTradeIdPost', 'tradeId', tradeId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('tradeTradeIdPost', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('tradeTradeIdPost', 'userSecret', userSecret)
            const localVarPath = `/trade/{tradeId}`
                .replace(`{${"tradeId"}}`, encodeURIComponent(String(tradeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradingApi - functional programming interface
 * @export
 */
export const TradingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdOrdersCancelPost(userId: string, userSecret: string, accountId: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdOrdersCancelPost(userId, userSecret, accountId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdOrdersGet(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccountOrderRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdOrdersGet(userId, userSecret, accountId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsAccountIdQuotesGet(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SymbolsQuotes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsAccountIdQuotesGet(userId, userSecret, symbols, accountId, useTicker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeImpact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId, calculatedTradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TradeExecutionStatus>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId, calculatedTradeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeImpactPost(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualTradeAndImpact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeImpactPost(userId, userSecret, manualTradeForm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradeOcoPostRequest} tradeOcoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeOcoPost(userId: string, userSecret: string, tradeOcoPostRequest: TradeOcoPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeOcoPost(userId, userSecret, tradeOcoPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tradeTradeIdPost(tradeId: string, userId: string, userSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountOrderRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tradeTradeIdPost(tradeId, userId, userSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TradingApi - factory interface
 * @export
 */
export const TradingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradingApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel open order in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOrdersCancelPost(userId: string, userSecret: string, accountId: string, body: string, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.accountsAccountIdOrdersCancelPost(userId, userSecret, accountId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all history of orders placed in account
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} accountId The ID of the account get positions.
         * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdOrdersGet(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: any): AxiosPromise<Array<AccountOrderRecord>> {
            return localVarFp.accountsAccountIdOrdersGet(userId, userSecret, accountId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get symbol quotes
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
         * @param {string} accountId The ID of the account to get quotes.
         * @param {boolean} [useTicker] Should be set to True if providing tickers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsAccountIdQuotesGet(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: any): AxiosPromise<SymbolsQuotes> {
            return localVarFp.accountsAccountIdQuotesGet(userId, userSecret, symbols, accountId, useTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the impact of placing a series of trades on the portfolio
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId: string, calculatedTradeId: string, options?: any): AxiosPromise<Array<TradeImpact>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId, calculatedTradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return details of a specific trade before it\'s placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: any): AxiosPromise<Trade> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify units of a trade before it is placed
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {string} tradeId The ID of trade object
         * @param {Trade} [trade] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: any): AxiosPromise<Trade> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place orders for the CalculatedTrades in series
         * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
         * @param {string} calculatedTradeId The ID of calculated trade to get account impact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId: string, calculatedTradeId: string, options?: any): AxiosPromise<Array<TradeExecutionStatus>> {
            return localVarFp.portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId, calculatedTradeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check impact of trades on account.
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {ManualTradeForm} manualTradeForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeImpactPost(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: any): AxiosPromise<ManualTradeAndImpact> {
            return localVarFp.tradeImpactPost(userId, userSecret, manualTradeForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place a OCO (One Cancels Other) order
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {TradeOcoPostRequest} tradeOcoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeOcoPost(userId: string, userSecret: string, tradeOcoPostRequest: TradeOcoPostRequest, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.tradeOcoPost(userId, userSecret, tradeOcoPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place order
         * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tradeTradeIdPost(tradeId: string, userId: string, userSecret: string, options?: any): AxiosPromise<AccountOrderRecord> {
            return localVarFp.tradeTradeIdPost(tradeId, userId, userSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradingApi - object-oriented interface
 * @export
 * @class TradingApi
 * @extends {BaseAPI}
 */
export class TradingApi extends BaseAPI {
    /**
     * 
     * @summary Cancel open order in account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public accountsAccountIdOrdersCancelPost(userId: string, userSecret: string, accountId: string, body: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).accountsAccountIdOrdersCancelPost(userId, userSecret, accountId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all history of orders placed in account
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} accountId The ID of the account get positions.
     * @param {'all' | 'open' | 'executed'} [state] defaults value is set to \&quot;all\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public accountsAccountIdOrdersGet(userId: string, userSecret: string, accountId: string, state?: 'all' | 'open' | 'executed', options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).accountsAccountIdOrdersGet(userId, userSecret, accountId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get symbol quotes
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} symbols List of universal_symbol_id or tickers to get quotes for.
     * @param {string} accountId The ID of the account to get quotes.
     * @param {boolean} [useTicker] Should be set to True if providing tickers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public accountsAccountIdQuotesGet(userId: string, userSecret: string, symbols: string, accountId: string, useTicker?: boolean, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).accountsAccountIdQuotesGet(userId, userSecret, symbols, accountId, useTicker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the impact of placing a series of trades on the portfolio
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdImpactGet(portfolioGroupId, calculatedTradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return details of a specific trade before it\'s placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdGet(portfolioGroupId, calculatedTradeId, tradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify units of a trade before it is placed
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {string} tradeId The ID of trade object
     * @param {Trade} [trade] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId: string, calculatedTradeId: string, tradeId: string, trade?: Trade, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdModifyTradeIdPatch(portfolioGroupId, calculatedTradeId, tradeId, trade, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place orders for the CalculatedTrades in series
     * @param {string} portfolioGroupId The ID of the PortfolioGroup to perform rebalancing calculations
     * @param {string} calculatedTradeId The ID of calculated trade to get account impact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId: string, calculatedTradeId: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).portfolioGroupsPortfolioGroupIdCalculatedtradesCalculatedTradeIdPlaceOrdersPost(portfolioGroupId, calculatedTradeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check impact of trades on account.
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {ManualTradeForm} manualTradeForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradeImpactPost(userId: string, userSecret: string, manualTradeForm: ManualTradeForm, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradeImpactPost(userId, userSecret, manualTradeForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place a OCO (One Cancels Other) order
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {TradeOcoPostRequest} tradeOcoPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradeOcoPost(userId: string, userSecret: string, tradeOcoPostRequest: TradeOcoPostRequest, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradeOcoPost(userId, userSecret, tradeOcoPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place order
     * @param {string} tradeId The ID of trade object obtained from trade/impact endpoint
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradingApi
     */
    public tradeTradeIdPost(tradeId: string, userId: string, userSecret: string, options?: AxiosRequestConfig) {
        return TradingApiFp(this.configuration).tradeTradeIdPost(tradeId, userId, userSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsAndReportingApi - axios parameter creator
 * @export
 */
export const TransactionsAndReportingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet: async (userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('activitiesGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('activitiesGet', 'userSecret', userSecret)
            const localVarPath = `/activities/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performanceCustomGet: async (startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('performanceCustomGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('performanceCustomGet', 'endDate', endDate)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('performanceCustomGet', 'userId', userId)
            // verify required parameter 'userSecret' is not null or undefined
            assertParamExists('performanceCustomGet', 'userSecret', userSecret)
            const localVarPath = `/performance/custom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PartnerClientId required
            await setApiKeyToObject(localVarQueryParameter, "clientId", configuration)

            // authentication PartnerSignature required
            await setApiKeyToObject(localVarHeaderParameter, "Signature", configuration)

            // authentication PartnerTimestamp required
            await setApiKeyToObject(localVarQueryParameter, "timestamp", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (accounts !== undefined) {
                localVarQueryParameter['accounts'] = accounts;
            }

            if (detailed !== undefined) {
                localVarQueryParameter['detailed'] = detailed;
            }

            if (frequency !== undefined) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (userSecret !== undefined) {
                localVarQueryParameter['userSecret'] = userSecret;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsAndReportingApi - functional programming interface
 * @export
 */
export const TransactionsAndReportingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsAndReportingApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activitiesGet(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalActivity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activitiesGet(userId, userSecret, startDate, endDate, accounts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async performanceCustomGet(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerformanceCustom>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.performanceCustomGet(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsAndReportingApi - factory interface
 * @export
 */
export const TransactionsAndReportingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsAndReportingApiFp(configuration)
    return {
        /**
         * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
         * @summary Get transaction history for a user
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activitiesGet(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: any): AxiosPromise<Array<UniversalActivity>> {
            return localVarFp.activitiesGet(userId, userSecret, startDate, endDate, accounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
         * @summary Get performance information for a specific timeframe
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {string} userId 
         * @param {string} userSecret 
         * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
         * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
         * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performanceCustomGet(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: any): AxiosPromise<PerformanceCustom> {
            return localVarFp.performanceCustomGet(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsAndReportingApi - object-oriented interface
 * @export
 * @class TransactionsAndReportingApi
 * @extends {BaseAPI}
 */
export class TransactionsAndReportingApi extends BaseAPI {
    /**
     * Returns activities (transactions) for a user. Specifing start and end date is highly recommended for automatic calls for better performance
     * @summary Get transaction history for a user
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsAndReportingApi
     */
    public activitiesGet(userId: string, userSecret: string, startDate?: string, endDate?: string, accounts?: string, options?: AxiosRequestConfig) {
        return TransactionsAndReportingApiFp(this.configuration).activitiesGet(userId, userSecret, startDate, endDate, accounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns performance information (contributions, dividends, rate of return, etc) for a specific timeframe. Total Equity Timeframe and Rate of Returns are experimental and should not be trusted to be 100% accurate
     * @summary Get performance information for a specific timeframe
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {string} userId 
     * @param {string} userSecret 
     * @param {string} [accounts] Optional comma seperated list of account IDs used to filter the request on specific accounts
     * @param {boolean} [detailed] Optional, increases frequency of data points for the total value and contribution charts if set to true
     * @param {string} [frequency] Optional frequency for the rate of return chart (defaults to monthly). Possible values are daily, weekly, monthly, quarterly, yearly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsAndReportingApi
     */
    public performanceCustomGet(startDate: string, endDate: string, userId: string, userSecret: string, accounts?: string, detailed?: boolean, frequency?: string, options?: AxiosRequestConfig) {
        return TransactionsAndReportingApiFp(this.configuration).performanceCustomGet(startDate, endDate, userId, userSecret, accounts, detailed, frequency, options).then((request) => request(this.axios, this.basePath));
    }
}


